<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#000000">
    <title>Interval Timer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
    <style>
        :root {
            color-scheme: dark;
            --system-blue: #007AFF;
            --system-emerald: #10b981;
            --system-orange: #f59e0b;
            --system-background: #000000;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background-color: var(--system-background);
            color: #FFFFFF;
            overflow: hidden;
            height: 100dvh;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        .apple-glass {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(30px);
            border: 1px solid rgba(255, 255, 255, 0.15);
        }

        .view-stack {
            position: relative;
            flex: 1;
            width: 100%;
            min-height: 0;
        }

        .tab-view {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black; 
            display: none; 
            flex-direction: column;
            overflow-y: auto;
            z-index: 1;
        }

        .tab-view.active {
            display: flex;
            z-index: 2;
        }

        .progress-ring__circle {
            transition: stroke 0.4s ease;
            transform: rotate(-90deg);
            transform-origin: 50% 50%;
            will-change: stroke-dashoffset;
        }

        .nav-container {
            position: relative;
            display: flex;
            background: rgba(255, 255, 255, 0.06);
            border-radius: 16px;
            padding: 4px;
            margin: 0 24px 24px 24px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            flex-shrink: 0;
        }

        .tab-btn {
            position: relative;
            flex: 1;
            padding: 8px 0;
            font-size: 11px;
            font-weight: 700;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.4);
            z-index: 10;
        }

        .tab-active { color: #FFFFFF; }

        .tab-indicator {
            position: absolute;
            top: 4px;
            left: 4px;
            height: calc(100% - 8px);
            width: calc(50% - 4px);
            background: rgba(255, 255, 255, 0.12);
            border-radius: 12px;
            transition: transform 0.3s cubic-bezier(0.2, 0, 0, 1);
            z-index: 5;
        }

        .ios-button {
            transition: transform 0.2s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.2s, background-color 0.2s;
        }

        .ios-button:active, .ios-button.is-pressed { transform: scale(0.92); opacity: 0.8; }

        /* --- Standardized Pressed States --- */
        #btn-start.is-pressed, #btn-pause.is-pressed { background-color: #d1d5db; }
        #btn-reset.is-pressed, #btn-skip.is-pressed { background-color: rgba(255, 255, 255, 0.2); color: white; }
        #btn-mute.is-pressed { background-color: rgba(255, 255, 255, 0.15); }
        .add-exercise-btn.is-pressed { background-color: rgba(255, 255, 255, 0.2); color: white; }
        
        /* For Routine & Export/Import buttons */
        .ios-button.bg-emerald-500\/10.is-pressed { background-color: rgba(16, 185, 129, 0.25) !important; }
        .ios-button.bg-blue-500\/10.is-pressed { background-color: rgba(59, 130, 246, 0.25) !important; }
        .ios-button.bg-gray-500\/10.is-pressed { background-color: rgba(107, 114, 128, 0.25) !important; }
        .ios-button.bg-red-500\/10.is-pressed { background-color: rgba(239, 68, 68, 0.25) !important; }
        .ios-button.bg-white\/5.is-pressed { background-color: rgba(255, 255, 255, 0.15) !important; }

        @keyframes pulseBig {
            0%, 100% { 
                transform: scale(1);
            }
            50% { 
                transform: scale(1.15);
            }
        }

        @keyframes pulseCircleGlow {
            0%, 100% { 
                stroke-width: 10;
                opacity: 0.7;
            }
            50% { 
                stroke-width: 12;
                opacity: 0.9;
            }
        }
        
        @keyframes pulseRadialGlow {
            0%, 100% { 
                opacity: 0.2;
                transform: scale(1);
            }
            50% { 
                opacity: 0.4;
                transform: scale(1.1);
            }
        }

        .pulse-text {
            animation: pulseBig 1s ease-in-out infinite;
        }

        .pulse-circle-stroke {
            animation: pulseCircleGlow 1s ease-in-out infinite;
        }
        
        .pulse-radial-glow {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(253, 224, 71, 0.25) 0%, rgba(253, 224, 71, 0.15) 30%, rgba(253, 224, 71, 0.06) 50%, rgba(253, 224, 71, 0.02) 70%, transparent 85%);
            animation: pulseRadialGlow 1s ease-in-out infinite;
            pointer-events: none;
            z-index: 1;
            filter: blur(12px);
        }

        @media (max-height: 700px) {
            header { padding-top: 1.5rem !important; margin-bottom: 0.5rem !important; }
            .nav-container { margin-bottom: 1rem !important; margin-left: 1.5rem !important; margin-right: 1.5rem !important; }
            #time-left { font-size: 4.5rem !important; }
            #current-exercise { font-size: 1.5rem !important; }
            .progress-svg-container { max-width: 260px !important; }
            .media-controls { margin-top: 0.5rem !important; gap: 1rem !important; }
            .exercise-label-container { height: 52px !important; }
            #view-timer { gap: 1rem !important; }
        }

        @media (max-width: 400px) {
            .progress-svg-container { 
                max-width: 340px !important; 
            }
            .exercise-label-container {
                width: 220px !important;
            }
            #current-exercise {
                font-size: 1.5rem !important;
            }
        }

        .exercise-label-container {
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 240px;
            overflow: hidden;
        }
        
        #current-exercise {
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.3;
            max-width: 100%;
            text-align: center;
            white-space: normal;
            word-break: break-word;
        }

        .exercise-row.dragging {
            opacity: 0.5;
            transform: scale(0.98);
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            pointer-events: none; /* Allows elementFromPoint to see what's underneath */
            transition: none;
        }

        .exercise-row.ghost {
            position: fixed;
            z-index: 1000;
            pointer-events: none;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            opacity: 1;
            background: #000;
            border-radius: 12px;
        }
        .exercise-row.placeholder {
            opacity: 0 !important;
        }
        
        .delete-btn {
            transition: all 0.2s;
            /* Note: .is-pressed state is now handled by the generic .ios-button.bg-white/5 rule */
        }

        #routine-select option {
            background-color: #1d1d1f;
            color: #ffffff;
        }

        #ac-ls-dropdown-select svg {
            transition: transform 0.2s;
        }
    </style>
</head>
<body>

    <div class="max-w-md w-full h-full flex flex-col relative overflow-hidden">
        
        <header class="flex justify-between items-center px-4 md:px-8 pt-10 mb-3 flex-shrink-0">
            <button onclick="switchTab('settings')" class="ios-button flex items-center justify-center h-12 w-12 rounded-2xl apple-glass border-white/5 shadow-xl text-white/70">
                <svg xmlns="http://www.w3.org/2000/svg" class="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                </svg>
            </button>
            <button id="btn-mute" onclick="toggleMute()" class="ios-button flex items-center justify-center h-12 w-12 rounded-2xl apple-glass border-white/5 shadow-xl">
                <svg id="icon-unmuted" xmlns="http://www.w3.org/2000/svg" class="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" />
                </svg>
                <svg id="icon-muted" xmlns="http://www.w3.org/2000/svg" class="w-6 h-6 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M18.364 18.364A9 9 0 005.636 5.636m12.728 12.728A9 9 0 015.636 5.636m12.728 12.728L5.636 5.636" />
                </svg>
            </button>
        </header>

        <div class="view-stack">
            <div id="view-timer" class="tab-view active pb-8 flex flex-col gap-6 justify-center h-full">
                <div class="relative w-full flex items-center justify-center px-4">
                    <div class="progress-svg-container relative w-full max-w-[360px] aspect-square flex items-center justify-center">
                        <svg class="absolute inset-0 w-full h-full z-0" viewBox="0 0 320 320">
                            <circle class="text-white/5" stroke-width="12" stroke="currentColor" fill="transparent" r="148" cx="160" cy="160" />
                            <circle id="progress-circle" class="progress-ring__circle text-blue-500" stroke-width="12" stroke-dasharray="930" stroke-dashoffset="0" stroke-linecap="round" stroke="currentColor" fill="transparent" r="148" cx="160" cy="160" />
                        </svg>
                        <div class="relative z-10 flex flex-col items-center justify-center text-center select-none p-4 w-full">
                            <div class="exercise-label-container">
                                <span id="current-exercise" class="text-blue-400 font-black tracking-wide uppercase text-3xl">Get Ready</span>
                            </div>
                            <span id="time-left" class="text-[5rem] font-black tracking-tighter tabular-nums leading-none mt-1">00:00</span>
                            <div class="mt-3 flex flex-col items-center min-h-[68px]">
                                <span id="circuit-display" class="text-sm font-bold text-blue-500/50 uppercase tracking-[0.2em] tabular-nums"> </span>
                                <span id="round-display" class="text-sm font-bold text-white/30 uppercase tracking-[0.2em] mt-1 tabular-nums">Ready</span>
                                <span id="total-time-display" class="text-sm font-bold text-white/60 uppercase tracking-[0.2em] mt-1 transition-opacity duration-300 tabular-nums">Total: --:--</span>
                                <div id="total-progress-bar-container" class="w-28 h-1.5 bg-white/10 rounded-full overflow-hidden mt-2 transition-opacity duration-300">
                                    <div id="total-progress-bar" class="h-full bg-blue-500 w-0 shadow-[0_0_10px_rgba(59,130,246,0.5)]"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="next-up-container" class="flex flex-col items-center justify-center opacity-0 transition-all duration-500">
                    <div class="flex items-center gap-2">
                        <span class="text-[8px] font-black text-white/20 uppercase tracking-[0.5em]">Next</span>
                        <span id="next-exercise-name" class="text-lg font-bold text-white/60 uppercase tracking-widest text-center">---</span>
                    </div>
                </div>

                <div class="media-controls w-full px-4 flex items-center justify-center gap-6 mt-2">
                    <button id="btn-reset" class="ios-button h-20 w-20 bg-white/5 text-white/70 rounded-full flex items-center justify-center border border-white/15 backdrop-blur-md font-semibold text-xs uppercase tracking-wider transition-all">
                        Reset
                    </button>
                    <div class="relative h-24 w-24">
                        <button id="btn-start" class="ios-button absolute inset-0 bg-white text-black rounded-full flex items-center justify-center shadow-2xl font-bold text-lg uppercase tracking-wide">
                            Start
                        </button>
                        <button id="btn-pause" class="ios-button hidden absolute inset-0 bg-white text-black rounded-full flex items-center justify-center shadow-2xl font-bold text-sm uppercase tracking-wide">
                            Pause
                        </button>
                    </div>
                    <button id="btn-skip" onclick="nextPhase(true)" class="ios-button h-20 w-20 bg-white/5 text-white/70 rounded-full flex items-center justify-center border border-white/15 backdrop-blur-md font-semibold text-xs uppercase tracking-wider transition-all">
                        Skip
                    </button>
                </div>
            </div>

            <div id="view-settings" class="tab-view px-4 md:px-8 pb-10">
                <div class="flex justify-between items-center pt-2 pb-4">
                    <h2 class="text-2xl font-bold text-white tracking-tight">Settings</h2>
                    <button onclick="switchTab('timer')" class="ios-button bg-blue-600 hover:bg-blue-500 text-white px-6 py-2 rounded-full text-xs font-bold uppercase tracking-wider transition-colors shadow-lg shadow-blue-900/20">Done</button>
                </div>
                <div class="space-y-4">
                    <!-- Routines - TOP -->
                    <div class="apple-glass rounded-[24px] p-5 space-y-3 relative z-20">
                        <label class="text-[10px] font-black text-white/40 uppercase tracking-widest mb-1 block">Saved Routines</label>
                        <div class="flex gap-2">
                            <div class="relative flex-1 group" id="custom-routine-dropdown">
                                <button id="ac-ls-dropdown-select" onclick="toggleDropdown()" class="w-full flex items-center justify-between bg-[#1d1d1f] hover:bg-[#2c2c2e] border border-[#424245] rounded-xl pl-4 pr-3 py-3 text-sm font-medium text-white transition-colors focus:border-[#0071e3] outline-none">
                                    <span id="ac-ls-dropdown-title" class="truncate">Select Routine</span>
                                    <svg class="w-3 h-3 text-[#86868b] ml-2" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"/></svg>
                                </button>
                                <div id="ac-ls-dropdown-options" class="absolute left-0 right-0 top-full mt-1 bg-[#1d1d1f] border border-[#424245] rounded-xl shadow-xl overflow-hidden hidden z-50 max-h-60 overflow-y-auto">
                                    <ul id="ac-ls-dropdown-options-list" class="py-1">
                                    </ul>
                                </div>
                            </div>
                        </div>
                        <div class="grid grid-cols-2 gap-2">
                            <button id="btn-update-routine" onclick="updateRoutine()" class="ios-button bg-emerald-500/10 hover:bg-emerald-500/20 border border-emerald-500/20 rounded-xl py-3 text-xs font-bold uppercase tracking-wider text-emerald-400 transition-all opacity-50 pointer-events-none">Update</button>
                            <button onclick="saveRoutine()" class="ios-button bg-blue-500/10 hover:bg-blue-500/20 border border-blue-500/20 rounded-xl py-3 text-xs font-bold uppercase tracking-wider text-blue-400 transition-colors">Save New</button>
                            <button id="btn-rename-routine" onclick="renameRoutine()" class="ios-button bg-gray-500/10 hover:bg-gray-500/20 border border-gray-500/20 rounded-xl py-3 text-xs font-bold uppercase tracking-wider text-gray-400 transition-all opacity-50 pointer-events-none">Rename</button>
                            <button onclick="deleteRoutine()" class="ios-button bg-red-500/10 hover:bg-red-500/20 border border-red-500/20 rounded-xl py-3 text-xs font-bold uppercase tracking-wider text-red-400 transition-colors">Delete</button>
                        </div>
                        <div class="flex gap-2 mt-2 pt-2 border-t border-white/5">
                            <input type="file" id="import-file" accept=".json" class="hidden" onchange="handleFileImport(this)">
                            <button onclick="exportRoutines()" class="flex-1 ios-button bg-white/5 hover:bg-white/10 rounded-xl py-2 text-[10px] font-bold uppercase tracking-wider text-white/40 transition-colors">Export JSON</button>
                            <button onclick="document.getElementById('import-file').click()" class="flex-1 ios-button bg-white/5 hover:bg-white/10 rounded-xl py-2 text-[10px] font-bold uppercase tracking-wider text-white/40 transition-colors">Import JSON</button>
                        </div>
                    </div>

                    <!-- Intervals - FIRST (Core Settings) -->
                    <div class="apple-glass rounded-[24px] p-5 space-y-3">
                        <label class="text-[10px] font-black text-white/40 uppercase tracking-widest mb-1 block">Intervals</label>
                        
                        <!-- Circuits - FIRST -->
                        <div class="grid grid-cols-[1fr_auto] gap-4 items-center py-1">
                            <span class="text-sm font-semibold text-white/70">Circuits</span>
                            <div class="flex items-center gap-2">
                                <span class="text-xl font-black tabular-nums text-white min-w-[3ch] text-right">
                                    <input 
                                        type="number" 
                                        id="input-rounds" 
                                        value="3" 
                                        min="1" 
                                        max="99"
                                        onclick="this.select()"
                                        class="w-12 bg-transparent text-xl font-black text-center outline-none tabular-nums">
                                </span>
                                <div class="flex items-center bg-white/5 rounded-xl border border-white/10 h-10">
                                    <button class="ios-button w-10 h-full flex items-center justify-center text-white/60 transition-colors rounded-l-xl" ontouchstart="startDecrement('input-rounds')" ontouchend="stopAdjustment()" onmousedown="if(!('ontouchstart' in window)) startDecrement('input-rounds')" onmouseup="stopAdjustment()" onmouseleave="stopAdjustment()">
                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="3" viewBox="0 0 24 24"><path stroke-linecap="round" d="M20 12H4"/></svg>
                                    </button>
                                    <div class="w-px h-4 bg-white/10"></div>
                                    <button class="ios-button w-10 h-full flex items-center justify-center text-white/60 transition-colors rounded-r-xl" ontouchstart="startIncrement('input-rounds')" ontouchend="stopAdjustment()" onmousedown="if(!('ontouchstart' in window)) startIncrement('input-rounds')" onmouseup="stopAdjustment()" onmouseleave="stopAdjustment()">
                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="3" viewBox="0 0 24 24"><path stroke-linecap="round" d="M12 4v16m8-8H4"/></svg>
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Divider -->
                        <div class="border-t border-white/10 my-2"></div>
                        
                        <!-- Prep -->
                        <div class="grid grid-cols-[1fr_auto] gap-4 items-center py-1">
                            <span class="text-sm font-semibold text-white/70">Prep</span>
                            <div class="flex items-center gap-2">
                                <input 
                                    type="text" 
                                    id="input-prepare" 
                                    value="00:10" 
                                    data-seconds="10"
                                    onclick="this.select()"
                                    onblur="handleTimeBlur('input-prepare')"
                                    class="w-16 bg-transparent text-xl font-black text-right outline-none tabular-nums">
                                <div class="flex items-center bg-white/5 rounded-xl border border-white/10 h-10">
                                    <button class="ios-button w-10 h-full flex items-center justify-center text-white/60 transition-colors rounded-l-xl" ontouchstart="startTimeDecrement('input-prepare', event)" ontouchend="stopAdjustment()" onmousedown="if(!('ontouchstart' in window)) startTimeDecrement('input-prepare', event)" onmouseup="stopAdjustment()" onmouseleave="stopAdjustment()">
                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="3" viewBox="0 0 24 24"><path stroke-linecap="round" d="M20 12H4"/></svg>
                                    </button>
                                    <div class="w-px h-4 bg-white/10"></div>
                                    <button class="ios-button w-10 h-full flex items-center justify-center text-white/60 transition-colors rounded-r-xl" ontouchstart="startTimeIncrement('input-prepare', event)" ontouchend="stopAdjustment()" onmousedown="if(!('ontouchstart' in window)) startTimeIncrement('input-prepare', event)" onmouseup="stopAdjustment()" onmouseleave="stopAdjustment()">
                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="3" viewBox="0 0 24 24"><path stroke-linecap="round" d="M12 4v16m8-8H4"/></svg>
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Exercise (was Work) -->
                        <div class="grid grid-cols-[1fr_auto] gap-4 items-center py-1">
                            <span class="text-sm font-semibold text-white/70">Exercise</span>
                            <div class="flex items-center gap-2">
                                <input 
                                    type="text" 
                                    id="input-work" 
                                    value="00:45" 
                                    data-seconds="45"
                                    onclick="this.select()"
                                    onblur="handleTimeBlur('input-work')"
                                    class="w-16 bg-transparent text-xl font-black text-right outline-none tabular-nums">
                                <div class="flex items-center bg-white/5 rounded-xl border border-white/10 h-10">
                                    <button class="ios-button w-10 h-full flex items-center justify-center text-white/60 transition-colors rounded-l-xl" ontouchstart="startTimeDecrement('input-work', event)" ontouchend="stopAdjustment()" onmousedown="if(!('ontouchstart' in window)) startTimeDecrement('input-work', event)" onmouseup="stopAdjustment()" onmouseleave="stopAdjustment()">
                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="3" viewBox="0 0 24 24"><path stroke-linecap="round" d="M20 12H4"/></svg>
                                    </button>
                                    <div class="w-px h-4 bg-white/10"></div>
                                    <button class="ios-button w-10 h-full flex items-center justify-center text-white/60 transition-colors rounded-r-xl" ontouchstart="startTimeIncrement('input-work', event)" ontouchend="stopAdjustment()" onmousedown="if(!('ontouchstart' in window)) startTimeIncrement('input-work', event)" onmouseup="stopAdjustment()" onmouseleave="stopAdjustment()">
                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="3" viewBox="0 0 24 24"><path stroke-linecap="round" d="M12 4v16m8-8H4"/></svg>
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Rest -->
                        <div class="grid grid-cols-[1fr_auto] gap-4 items-center py-1">
                            <span class="text-sm font-semibold text-white/70">Rest</span>
                            <div class="flex items-center gap-2">
                                <input 
                                    type="text" 
                                    id="input-rest" 
                                    value="00:15" 
                                    data-seconds="15"
                                    onclick="this.select()"
                                    onblur="handleTimeBlur('input-rest')"
                                    class="w-16 bg-transparent text-xl font-black text-right outline-none tabular-nums">
                                <div class="flex items-center bg-white/5 rounded-xl border border-white/10 h-10">
                                    <button class="ios-button w-10 h-full flex items-center justify-center text-white/60 transition-colors rounded-l-xl" ontouchstart="startTimeDecrement('input-rest', event)" ontouchend="stopAdjustment()" onmousedown="if(!('ontouchstart' in window)) startTimeDecrement('input-rest', event)" onmouseup="stopAdjustment()" onmouseleave="stopAdjustment()">
                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="3" viewBox="0 0 24 24"><path stroke-linecap="round" d="M20 12H4"/></svg>
                                    </button>
                                    <div class="w-px h-4 bg-white/10"></div>
                                    <button class="ios-button w-10 h-full flex items-center justify-center text-white/60 transition-colors rounded-r-xl" ontouchstart="startTimeIncrement('input-rest', event)" ontouchend="stopAdjustment()" onmousedown="if(!('ontouchstart' in window)) startTimeIncrement('input-rest', event)" onmouseup="stopAdjustment()" onmouseleave="stopAdjustment()">
                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="3" viewBox="0 0 24 24"><path stroke-linecap="round" d="M12 4v16m8-8H4"/></svg>
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- Cool Down -->
                        <div class="grid grid-cols-[1fr_auto] gap-4 items-center py-1">
                            <span class="text-sm font-semibold text-white/70">Cool Down</span>
                            <div class="flex items-center gap-2">
                                <input 
                                    type="text" 
                                    id="input-cooldown" 
                                    value="00:00" 
                                    data-seconds="0"
                                    onclick="this.select()"
                                    onblur="handleTimeBlur('input-cooldown')"
                                    class="w-16 bg-transparent text-xl font-black text-right outline-none tabular-nums">
                                <div class="flex items-center bg-white/5 rounded-xl border border-white/10 h-10">
                                    <button class="ios-button w-10 h-full flex items-center justify-center text-white/60 transition-colors rounded-l-xl" ontouchstart="startTimeDecrement('input-cooldown', event)" ontouchend="stopAdjustment()" onmousedown="if(!('ontouchstart' in window)) startTimeDecrement('input-cooldown', event)" onmouseup="stopAdjustment()" onmouseleave="stopAdjustment()">
                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="3" viewBox="0 0 24 24"><path stroke-linecap="round" d="M20 12H4"/></svg>
                                    </button>
                                    <div class="w-px h-4 bg-white/10"></div>
                                    <button class="ios-button w-10 h-full flex items-center justify-center text-white/60 transition-colors rounded-r-xl" ontouchstart="startTimeIncrement('input-cooldown', event)" ontouchend="stopAdjustment()" onmousedown="if(!('ontouchstart' in window)) startTimeIncrement('input-cooldown', event)" onmouseup="stopAdjustment()" onmouseleave="stopAdjustment()">
                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="3" viewBox="0 0 24 24"><path stroke-linecap="round" d="M12 4v16m8-8H4"/></svg>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Exercise List - SECOND -->
                    <div class="apple-glass rounded-[24px] p-5 space-y-3">
                        <div class="flex justify-between items-end">
                            <label class="text-[10px] font-black text-white/40 uppercase tracking-widest">Exercise List</label>
                            <span class="text-[9px] text-white/30 uppercase tracking-wider">Duration (Optional)</span>
                        </div>
                        
                        <div id="exercises-list" class="space-y-2"></div>
                        
                        <button onclick="addNewExerciseRow()" class="add-exercise-btn ios-button w-full py-3 rounded-xl bg-white/5 border border-white/10 text-xs font-bold uppercase tracking-wider text-white/60 transition-all flex items-center justify-center gap-2">
                            <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-width="3" d="M12 4v16m8-8H4"/></svg>
                            Add Exercise
                        </button>
                    </div>

                    <!-- Audio Settings - THIRD -->
                    <div class="apple-glass rounded-[24px] p-5 space-y-3">
                        <label class="text-[10px] font-black text-white/40 uppercase tracking-widest mb-1 block">Audio</label>
                        
                        <div class="relative flex bg-white/[0.06] border border-white/[0.08] rounded-2xl p-1">
                            <button 
                                id="btn-audio-voice"
                                onclick="setAudioType('voice')"
                                class="tab-btn tab-active">
                                Voice
                            </button>
                            <button 
                                id="btn-audio-beep"
                                onclick="setAudioType('beep')"
                                class="tab-btn">
                                Beep
                            </button>
                            <div id="audio-indicator" class="tab-indicator"></div>
                        </div>
                    </div>
                </div>
            </div>
                </div>
            </div>
        </div>

        <div id="message-box" class="fixed top-8 left-1/2 -translate-x-1/2 px-8 py-3 rounded-full apple-glass text-white font-black text-[10px] shadow-2xl transition-all opacity-0 pointer-events-none z-50 uppercase tracking-widest">Workout Complete</div>
    
        <!-- Custom Modal -->
        <div id="custom-modal" class="absolute inset-0 z-[100] flex items-center justify-center bg-black/60 backdrop-blur-sm hidden opacity-0 transition-opacity duration-300">
            <div id="modal-content" class="apple-glass p-6 rounded-[24px] w-[85%] max-w-xs transform scale-95 transition-transform duration-300 flex flex-col gap-4 shadow-2xl">
                <h3 id="modal-title" class="text-lg font-bold text-white text-center">Title</h3>
                <p id="modal-message" class="text-sm text-white/60 text-center leading-relaxed hidden">Message</p>
                <input id="modal-input" type="text" class="w-full bg-white/10 border border-white/10 rounded-xl px-4 py-3 text-base text-white outline-none focus:bg-white/15 transition-colors hidden" autocomplete="off">
                <div class="grid grid-cols-2 gap-3 mt-2" id="modal-buttons">
                    <button id="modal-cancel" class="ios-button bg-white/5 hover:bg-white/10 rounded-xl py-3 text-sm font-semibold text-white/60">Cancel</button>
                    <button id="modal-confirm" class="ios-button bg-blue-500 hover:bg-blue-600 text-white rounded-xl py-3 text-sm font-semibold">OK</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // WAKE LOCK MANAGER
        // ============================================
        class WakeLockManager {
            constructor() {
                this.wakeLock = null;
                this.isSupported = 'wakeLock' in navigator;
            }

            async enable() {
                if (!this.isSupported) {
                    console.warn('Wake Lock API is not supported in this browser');
                    return;
                }

                try {
                    this.wakeLock = await navigator.wakeLock.request('screen');
                    console.log('âœ“ Wake Lock enabled - screen will stay on');
                    
                    this.wakeLock.addEventListener('release', () => {
                        console.log('Wake Lock was released');
                    });
                } catch (err) {
                    console.error('Failed to enable Wake Lock:', err);
                }
            }

            async disable() {
                if (this.wakeLock) {
                    try {
                        await this.wakeLock.release();
                        this.wakeLock = null;
                        console.log('âœ“ Wake Lock disabled');
                    } catch (err) {
                        console.error('Error releasing Wake Lock:', err);
                    }
                }
            }

            async reEnable() {
                if (this.wakeLock !== null || this.isSupported) {
                    await this.disable();
                    await this.enable();
                }
            }
        }

        const wakeLockManager = new WakeLockManager();

        // ============================================
        // SPEECH SYNTHESIS MANAGER (iOS-Compatible)
        // ============================================
        class SpeechManager {
            constructor() {
                this.isInitialized = false;
                this.isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            }

            initialize() {
                if (this.isInitialized) return;
                
                if (this.isIOS && 'speechSynthesis' in window) {
                    const utterance = new SpeechSynthesisUtterance(' ');
                    utterance.volume = 0;
                    window.speechSynthesis.speak(utterance);
                    this.isInitialized = true;
                    console.log('âœ“ Speech synthesis initialized for iOS');
                } else {
                    this.isInitialized = true;
                }
            }

            speak(text, voiceEnabled) {
                if (!voiceEnabled) return;
                
                if (!this.isInitialized) {
                    this.initialize();
                }

                window.speechSynthesis.cancel();

                setTimeout(() => {
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.rate = 1.1;
                    utterance.volume = 1.0;
                    utterance.lang = 'en-US';
                    
                    if (this.isIOS) {
                        utterance.rate = 1.0;
                    }
                    
                    window.speechSynthesis.speak(utterance);
                    console.log('ðŸ”Š Speaking:', text);
                }, this.isIOS ? 100 : 0);
            }

            cancel() {
                window.speechSynthesis.cancel();
            }
        }

        const speechManager = new SpeechManager();

        // ============================================
        // SOUND MANAGER (Beeps)
        // ============================================
        class SoundManager {
            constructor() {
                this.cache = {}; // Will store pre-loaded Audio elements
                this.isUnlocked = false;
            }

            // Pre-create and load all required audio elements.
            // This must be called within a user gesture on iOS.
            primeAllSounds() {
                const soundsToPrime = [
                    { freq: 1200, duration: 0.1 },  // Countdown
                    { freq: 800, duration: 0.15 }, // Work Start
                    { freq: 400, duration: 0.15 }, // Rest Start
                    { freq: 700, duration: 0.12 }, // Complete 1
                    { freq: 900, duration: 0.12 }, // Complete 2
                    { freq: 1100, duration: 0.18 }, // Complete 3
                ];

                soundsToPrime.forEach(({ freq, duration }) => {
                    const key = `${freq}-${duration}`;
                    if (!this.cache[key]) {
                        const url = this.createBeepUrl(freq, duration, 30);
                        const audio = new Audio(url);
                        audio.load(); // Important: load the audio data
                        this.cache[key] = audio;
                    }
                });
            }

            // Generate a WAV file blob URL
            createBeepUrl(freq, duration, vol = 100) {
                const sampleRate = 44100;
                const bitsPerSample = 16;
                const bytesPerSample = bitsPerSample / 8;
                const numSamples = Math.floor(duration * sampleRate);
                const buffer = new Uint8Array(44 + numSamples * bytesPerSample);
                const view = new DataView(buffer.buffer);

                const writeString = (offset, string) => {
                    for (let i = 0; i < string.length; i++) {
                        view.setUint8(offset + i, string.charCodeAt(i));
                    }
                };

                // RIFF chunk
                writeString(0, 'RIFF');
                view.setUint32(4, 36 + numSamples * bytesPerSample, true);
                writeString(8, 'WAVE');

                // fmt chunk
                writeString(12, 'fmt ');
                view.setUint32(16, 16, true); // Subchunk1Size (16 for PCM)
                view.setUint16(20, 1, true); // AudioFormat (1 for PCM)
                view.setUint16(22, 1, true); // NumChannels (1 for Mono)
                view.setUint32(24, sampleRate, true); // SampleRate
                view.setUint32(28, sampleRate * bytesPerSample, true); // ByteRate
                view.setUint16(32, bytesPerSample, true); // BlockAlign
                view.setUint16(34, bitsPerSample, true); // BitsPerSample

                // data chunk
                writeString(36, 'data');
                view.setUint32(40, numSamples * bytesPerSample, true);

                // Write sample data
                for (let i = 0; i < numSamples; i++) {
                    const t = i / sampleRate;
                    const val = Math.sin(2 * Math.PI * freq * t);

                    // Apply exponential decay to mimic the "solid" oscillator envelope
                    const envelope = Math.pow(0.01, i / numSamples);

                    // 16-bit audio: -32767 to 32767.
                    const sampleValue = val * 32767 * (vol / 100) * envelope;
                    view.setInt16(44 + i * bytesPerSample, sampleValue, true);
                }

                const blob = new Blob([buffer], { type: 'audio/wav' });
                return URL.createObjectURL(blob);
            }

            async unlock() {
                if (this.isUnlocked) return;

                this.primeAllSounds();

                // Play a silent sound to satisfy the gesture requirement and unlock the channel
                const silentUrl = this.createBeepUrl(0, 0.01, 0);
                const silentAudio = new Audio(silentUrl);
                try {
                    await silentAudio.play();
                    this.isUnlocked = true;
                    console.log('âœ“ Audio channel unlocked');
                } catch (e) {
                    console.error('Audio unlock failed', e);
                }
            }

            playTone(freq, duration) {
                if (!this.isUnlocked) {
                    console.warn('Audio not unlocked, cannot play tone.');
                    return;
                }
                const key = `${freq}-${duration}`;
                const audio = this.cache[key];
                
                if (audio) {
                    audio.currentTime = 0;
                    audio.play().catch(e => console.error(`Play failed for ${key}:`, e));
                } else {
                    console.error(`Sound not primed: ${key}`);
                }
            }

            playCountdown() {
                this.playTone(1200, 0.1);
            }

            playWorkStart() {
                // Classic double beep
                this.playTone(800, 0.15);
                setTimeout(() => this.playTone(800, 0.15), 200);
            }

            playRestStart() {
                this.playTone(400, 0.15);
            }

            playComplete() {
                // Classic victory sequence
                this.playTone(700, 0.12);
                setTimeout(() => this.playTone(900, 0.12), 150);
                setTimeout(() => this.playTone(1100, 0.18), 300);
            }
        }

        const soundManager = new SoundManager();

        // ============================================
        // TIMER CODE
        // ============================================
        const CIRCLE_RADIUS = 148;
        const CIRCUMFERENCE = 2 * Math.PI * CIRCLE_RADIUS;
        let timer = null, isPaused = false, currentPhase = 'prepare', globalIntervalIndex = 0, secondsRemaining = 0, totalPhaseSeconds = 0, totalTimeRemaining = 0, initialTotalTime = 0, exerciseObjects = [], phaseEndTime = 0, pausedTimeRemainingMs = 0, workoutEndTime = 0, pauseStartTime = 0;

        const timeLeftEl = document.getElementById('time-left');
        const roundDisplayEl = document.getElementById('round-display');
        const circuitDisplayEl = document.getElementById('circuit-display');
        const totalTimeDisplayEl = document.getElementById('total-time-display');
        const exerciseTextEl = document.getElementById('current-exercise');
        const totalProgressBar = document.getElementById('total-progress-bar');
        const totalProgressBarContainer = document.getElementById('total-progress-bar-container');
        const progressCircle = document.getElementById('progress-circle');
        const navIndicator = document.getElementById('nav-indicator');
        const btnMute = document.getElementById('btn-mute');
        const iconMuted = document.getElementById('icon-muted');
        const iconUnmuted = document.getElementById('icon-unmuted');
        const btnStart = document.getElementById('btn-start');
        const btnPause = document.getElementById('btn-pause');
        const nextUpContainer = document.getElementById('next-up-container');
        const nextExerciseNameEl = document.getElementById('next-exercise-name');
        const inputWork = document.getElementById('input-work'), inputRest = document.getElementById('input-rest'), inputRounds = document.getElementById('input-rounds'), inputPrepare = document.getElementById('input-prepare');
        
        // Native Data Model (Source of Truth)
        let exercisesData = [
            { name: "Jumping jacks", duration: null },
            { name: "Push ups", duration: 30 },
            { name: "Crunches", duration: null },
            { name: "Walk outs", duration: null },
            { name: "Squats", duration: null },
            { name: "Mountain climbers", duration: null }
        ];
        
        // Voice state variable (controlled by mute button)
        let voiceEnabled = true;
        let audioType = 'voice'; // 'voice' or 'beep'
        
        // ============================================
        // ROUTINE MANAGER
        // ============================================
        let savedRoutines = [];
        let currentRoutineIndex = -1;

        function loadRoutines() {
            const stored = localStorage.getItem('intervalTimerRoutines');
            if (stored) {
                try {
                    savedRoutines = JSON.parse(stored);
                } catch (e) {
                    console.error('Error loading routines', e);
                    savedRoutines = [];
                }
            }
            updateRoutineSelect();
        }

        function updateRoutineSelect() {
            const list = document.getElementById('ac-ls-dropdown-options-list');
            if (!list) return;
            
            list.innerHTML = '';
            
            if (savedRoutines.length === 0) {
                 const li = document.createElement('li');
                 li.className = 'px-3 py-2 text-sm text-white/50 italic';
                 li.textContent = 'No saved routines';
                 list.appendChild(li);
                 return;
            }

            savedRoutines.forEach((routine, index) => {
                const li = document.createElement('li');
                li.className = 'ac-ls-dropdown-option px-3 py-2 text-sm font-medium text-white hover:bg-[#2c2c2e] cursor-pointer flex items-center gap-2';
                li.onclick = () => {
                    loadRoutine(index);
                    toggleDropdown(false);
                };
                li.innerHTML = `<span class="w-3 h-3 flex items-center justify-center text-[#0071e3] ${index === currentRoutineIndex ? '' : 'opacity-0'} check-icon"><svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="2"><path d="M2 6l3 3 5-5"/></svg></span><span>${routine.name}</span>`;
                list.appendChild(li);
            });
            updateRoutineButtonsState();
        }

        async function saveRoutine() {
            const name = await showModal({
                title: 'Save Routine',
                showInput: true,
                inputPlaceholder: 'Routine Name',
                confirmText: 'Save'
            });
            
            if (!name) return;

            const newRoutine = {
                name: name,
                exercises: JSON.parse(JSON.stringify(exercisesData)),
                workTime: getSecondsFromTimeInput('input-work'),
                restTime: getSecondsFromTimeInput('input-rest'),
                circuits: inputRounds.value,
                prepTime: getSecondsFromTimeInput('input-prepare'),
                coolDownTime: getSecondsFromTimeInput('input-cooldown'),
                voiceEnabled: voiceEnabled,
                audioType: audioType
            };

            savedRoutines.push(newRoutine);
            localStorage.setItem('intervalTimerRoutines', JSON.stringify(savedRoutines));
            updateRoutineSelect();
            
            // Select the new routine
            loadRoutine(savedRoutines.length - 1);
        }

        async function updateRoutine() {
            if (currentRoutineIndex === -1) return;
            
            const routine = savedRoutines[currentRoutineIndex];
            const confirmed = await showModal({
                title: 'Update Routine',
                message: `Update "${routine.name}" with current settings?`,
                confirmText: 'Update',
                confirmColor: 'bg-emerald-500'
            });
            
            if (!confirmed) return;

            const updatedRoutine = {
                name: routine.name,
                exercises: JSON.parse(JSON.stringify(exercisesData)),
                workTime: getSecondsFromTimeInput('input-work'),
                restTime: getSecondsFromTimeInput('input-rest'),
                circuits: inputRounds.value,
                prepTime: getSecondsFromTimeInput('input-prepare'),
                coolDownTime: getSecondsFromTimeInput('input-cooldown'),
                voiceEnabled: voiceEnabled,
                audioType: audioType
            };

            savedRoutines[currentRoutineIndex] = updatedRoutine;
            localStorage.setItem('intervalTimerRoutines', JSON.stringify(savedRoutines));
            
            // Visual feedback
            const btn = document.getElementById('btn-update-routine');
            const originalText = btn.innerText;
            btn.innerText = "Saved!";
            setTimeout(() => btn.innerText = originalText, 1500);
        }

        async function deleteRoutine() {
            if (currentRoutineIndex === -1) {
                await showModal({
                    title: 'No Routine Selected',
                    message: 'Please select a routine to delete.',
                    confirmText: 'OK',
                    cancelText: null,
                    confirmColor: 'bg-white/10'
                });
                return;
            }
            
            const confirmed = await showModal({
                title: 'Delete Routine',
                message: `Delete "${savedRoutines[currentRoutineIndex].name}"?`,
                confirmText: 'Delete',
                confirmColor: 'bg-red-500'
            });
            
            if (!confirmed) return;

            savedRoutines.splice(currentRoutineIndex, 1);
            localStorage.setItem('intervalTimerRoutines', JSON.stringify(savedRoutines));
            currentRoutineIndex = -1;
            document.getElementById('ac-ls-dropdown-title').textContent = "Select Routine";
            updateRoutineSelect();
            saveSettings();
        }

        async function renameRoutine() {
            if (currentRoutineIndex === -1) {
                await showModal({
                    title: 'No Routine Selected',
                    message: 'Please select a routine to rename.',
                    confirmText: 'OK',
                    cancelText: null,
                    confirmColor: 'bg-white/10'
                });
                return;
            }

            const routine = savedRoutines[currentRoutineIndex];
            const newName = await showModal({
                title: 'Rename Routine',
                showInput: true,
                inputValue: routine.name,
                inputPlaceholder: 'New Routine Name',
                confirmText: 'Rename'
            });

            if (!newName || newName.trim() === '' || newName.trim() === routine.name) return;

            savedRoutines[currentRoutineIndex].name = newName.trim();
            localStorage.setItem('intervalTimerRoutines', JSON.stringify(savedRoutines));
            document.getElementById('ac-ls-dropdown-title').textContent = newName.trim();
            updateRoutineSelect();
        }

        function exportRoutines() {
            if (savedRoutines.length === 0) {
                showModal({
                    title: 'No Routines',
                    message: 'You have no saved routines to export.',
                    confirmText: 'OK',
                    cancelText: null
                });
                return;
            }
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(savedRoutines, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "interval_timer_routines.json");
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        }

        function handleFileImport(input) {
            const file = input.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    const imported = JSON.parse(e.target.result);
                    if (Array.isArray(imported)) {
                        const confirmed = await showModal({
                            title: 'Import Routines',
                            message: `Found ${imported.length} routines. Import and append to your current list?`,
                            confirmText: 'Import',
                            confirmColor: 'bg-blue-500'
                        });

                        if (confirmed) {
                            savedRoutines = [...savedRoutines, ...imported];
                            localStorage.setItem('intervalTimerRoutines', JSON.stringify(savedRoutines));
                            updateRoutineSelect();
                            await showModal({
                                title: 'Success',
                                message: 'Routines imported successfully!',
                                confirmText: 'OK',
                                cancelText: null
                            });
                        }
                    }
                } catch (err) {
                    console.error(err);
                }
                input.value = ''; // Reset input
            };
            reader.readAsText(file);
        }

        function loadRoutine(index) {
            if (index === "" || index === -1) {
                return;
            }
            
            const routine = savedRoutines[index];
            if (!routine) return;
            
            currentRoutineIndex = parseInt(index);
            document.getElementById('ac-ls-dropdown-title').textContent = routine.name;
            updateRoutineSelect();
            
            // Apply settings
            exercisesData = JSON.parse(JSON.stringify(routine.exercises)); // Deep copy
            setTimeInputSeconds('input-work', routine.workTime);
            setTimeInputSeconds('input-rest', routine.restTime);
            setTimeInputSeconds('input-prepare', routine.prepTime);
            setTimeInputSeconds('input-cooldown', routine.coolDownTime || 0);
            inputRounds.value = routine.circuits;
            
            if (routine.voiceEnabled !== undefined) {
                voiceEnabled = routine.voiceEnabled;
                handleMuteToggle(voiceEnabled);
            }
            
            if (routine.audioType) {
                setAudioType(routine.audioType);
            }
            
            renderExerciseList();
            saveSettings(); // Save as current active settings
            updateTotalTimeDisplay();
            updateCountsDisplay();
        }

        function updateRoutineButtonsState() {
            const updateBtn = document.getElementById('btn-update-routine');
            const renameBtn = document.getElementById('btn-rename-routine');
            const shouldBeEnabled = currentRoutineIndex !== -1;

            [updateBtn, renameBtn].forEach(btn => {
                if (!btn) return;
                btn.classList.toggle('opacity-50', !shouldBeEnabled);
                btn.classList.toggle('pointer-events-none', !shouldBeEnabled);
            });
        }

        function toggleDropdown(show) {
            const options = document.getElementById('ac-ls-dropdown-options');
            const button = document.getElementById('ac-ls-dropdown-select');
            const arrow = button.querySelector('svg');
            
            if (show === undefined) {
                show = options.classList.contains('hidden');
            }
            
            if (show) {
                options.classList.remove('hidden');
                button.setAttribute('aria-expanded', 'true');
                arrow.style.transform = 'rotate(180deg)';
            } else {
                options.classList.add('hidden');
                button.setAttribute('aria-expanded', 'false');
                arrow.style.transform = 'rotate(0deg)';
            }
        }

        // ============================================
        // CUSTOM MODAL MANAGER
        // ============================================
        function showModal({ title, message, showInput = false, inputValue = '', inputPlaceholder = '', confirmText = 'OK', confirmColor = 'bg-blue-500', cancelText = 'Cancel' }) {
            return new Promise((resolve) => {
                const modal = document.getElementById('custom-modal');
                const content = document.getElementById('modal-content');
                const titleEl = document.getElementById('modal-title');
                const msgEl = document.getElementById('modal-message');
                const inputEl = document.getElementById('modal-input');
                const confirmBtn = document.getElementById('modal-confirm');
                const cancelBtn = document.getElementById('modal-cancel');
                const btnContainer = document.getElementById('modal-buttons');

                titleEl.innerText = title;
                
                if (message) {
                    msgEl.innerText = message;
                    msgEl.classList.remove('hidden');
                } else {
                    msgEl.classList.add('hidden');
                }

                if (showInput) {
                    inputEl.value = inputValue;
                    inputEl.placeholder = inputPlaceholder;
                    inputEl.classList.remove('hidden');
                    setTimeout(() => inputEl.focus(), 50);
                } else {
                    inputEl.classList.add('hidden');
                }

                confirmBtn.innerText = confirmText;
                confirmBtn.className = `ios-button ${confirmColor} hover:opacity-90 text-white rounded-xl py-3 text-sm font-semibold transition-all`;
                
                if (!cancelText) {
                    cancelBtn.classList.add('hidden');
                    btnContainer.classList.remove('grid-cols-2');
                    btnContainer.classList.add('grid-cols-1');
                } else {
                    cancelBtn.innerText = cancelText;
                    cancelBtn.classList.remove('hidden');
                    btnContainer.classList.add('grid-cols-2');
                    btnContainer.classList.remove('grid-cols-1');
                }

                modal.classList.remove('hidden');
                requestAnimationFrame(() => {
                    modal.classList.remove('opacity-0');
                    content.classList.remove('scale-95');
                    content.classList.add('scale-100');
                });

                const close = (result) => {
                    modal.classList.add('opacity-0');
                    content.classList.remove('scale-100');
                    content.classList.add('scale-95');
                    setTimeout(() => {
                        modal.classList.add('hidden');
                        resolve(result);
                    }, 200);
                    
                    confirmBtn.onclick = null;
                    cancelBtn.onclick = null;
                    inputEl.onkeydown = null;
                };

                confirmBtn.onclick = () => close(showInput ? inputEl.value : true);
                cancelBtn.onclick = () => close(false);
                
                if (showInput) {
                    inputEl.onkeydown = (e) => {
                        if (e.key === 'Enter') close(inputEl.value);
                    };
                }
            });
        }

        function saveSettings() {
            const settings = {
                exercises: exercisesData,
                workTime: getSecondsFromTimeInput('input-work'),
                restTime: getSecondsFromTimeInput('input-rest'),
                circuits: inputRounds.value,
                prepTime: getSecondsFromTimeInput('input-prepare'),
                coolDownTime: getSecondsFromTimeInput('input-cooldown'),
                voiceEnabled: voiceEnabled,
                audioType: audioType,
                routineIndex: currentRoutineIndex
            };
            localStorage.setItem('intervalTimerSettings', JSON.stringify(settings));
        }

        function loadSettings() {
            const saved = localStorage.getItem('intervalTimerSettings');
            if (saved) {
                try {
                    const settings = JSON.parse(saved);
                    
                    // Handle legacy string format or new array format
                    if (settings.exercises) {
                        if (typeof settings.exercises === 'string') {
                            exercisesData = settings.exercises.split(',').filter(i => i.trim() !== "").map(item => {
                                const parts = item.split(':');
                                return { name: parts[0].trim(), duration: (parts[1] && !isNaN(parseInt(parts[1].trim()))) ? parseInt(parts[1].trim()) : null };
                            });
                        } else if (Array.isArray(settings.exercises)) {
                            exercisesData = settings.exercises;
                        }
                    }
                    
                    // Load time values
                    if (settings.workTime !== undefined) {
                        setTimeInputSeconds('input-work', settings.workTime);
                    }
                    if (settings.restTime !== undefined) {
                        setTimeInputSeconds('input-rest', settings.restTime);
                    }
                    if (settings.prepTime !== undefined) {
                        setTimeInputSeconds('input-prepare', settings.prepTime);
                    }
                    if (settings.coolDownTime !== undefined) {
                        setTimeInputSeconds('input-cooldown', settings.coolDownTime);
                    }
                    
                    inputRounds.value = settings.circuits || inputRounds.value;
                    voiceEnabled = settings.voiceEnabled !== undefined ? settings.voiceEnabled : true;
                    handleMuteToggle(voiceEnabled);
                    
                    // Load audio type
                    audioType = settings.audioType || 'voice';
                    
                    // Load selected routine index
                    if (settings.routineIndex !== undefined) {
                        if (settings.routineIndex !== -1 && savedRoutines[settings.routineIndex]) {
                            currentRoutineIndex = settings.routineIndex;
                            document.getElementById('ac-ls-dropdown-title').textContent = savedRoutines[currentRoutineIndex].name;
                        } else {
                            currentRoutineIndex = -1;
                        }
                        updateRoutineButtonsState();
                    }

                    updateAudioTypeUI();
                    renderExerciseList();
                } catch (e) {
                    console.error('Error loading settings:', e);
                }
            }
        }
        
        function setAudioType(type) {
            audioType = type;
            updateAudioTypeUI();
            saveSettings();
        }
        
        function updateAudioTypeUI() {
            const voiceBtn = document.getElementById('btn-audio-voice');
            const beepBtn = document.getElementById('btn-audio-beep');
            const indicator = document.getElementById('audio-indicator');
            
            if (!voiceBtn || !beepBtn || !indicator) return;
            
            if (audioType === 'voice') {
                voiceBtn.classList.add('tab-active');
                beepBtn.classList.remove('tab-active');
                indicator.style.transform = 'translateX(0%)';
            } else {
                voiceBtn.classList.remove('tab-active');
                beepBtn.classList.add('tab-active');
                indicator.style.transform = 'translateX(100%)';
            }
        }

        function setupAutoSave() {
            [inputWork, inputRest, inputRounds, inputPrepare, document.getElementById('input-cooldown')].forEach(el => {
                el.addEventListener('input', () => {
                    saveSettings();
                    updateTotalTimeDisplay();
                    updateCountsDisplay();
                });
                
                el.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.target.blur();
                    }
                });
            });
        }

        // ============================================
        // EXERCISE LIST UI HANDLERS
        // ============================================
        function renderExerciseList() {
            const container = document.getElementById('exercises-list');
            if (!container) return;
            container.innerHTML = '';
            
            exercisesData.forEach(item => {
                createExerciseRow(item.name, item.duration || '');
            });
            
            if (exercisesData.length === 0) createExerciseRow('', '');
        }

        function createExerciseRow(name = '', duration = '') {
            const container = document.getElementById('exercises-list');
            const div = document.createElement('div');
            
            // Format duration if it exists
            const formattedDuration = (duration !== '' && duration !== null) ? formatToMMSS(duration) : '';
            
            // Add transition classes for entry animation
            div.className = 'exercise-row relative overflow-hidden rounded-xl transition-all duration-300 ease-out opacity-0 translate-y-2 max-h-0 select-none';
            div.innerHTML = `
                <div class="row-content w-full flex items-center bg-white/5 py-3 px-4">
                    <input type="text" value="${name}" placeholder="Exercise Name" class="exercise-name-input flex-1 min-w-0 bg-transparent border-none p-0 text-sm font-medium focus:ring-0 outline-none placeholder:text-white/20 text-white">
                    
                    <input type="text" value="${formattedDuration}" placeholder="--:--" onclick="this.select()" class="exercise-duration-input w-16 bg-transparent border-none p-0 text-sm text-right focus:ring-0 outline-none placeholder:text-white/20 text-white tabular-nums font-bold mx-3">

                    <button onclick="removeExerciseRow(this)" class="delete-btn ios-button w-8 h-8 flex-shrink-0 flex items-center justify-center rounded-full bg-white/5 text-white/30 hover:bg-white/10 hover:text-white transition-all ml-1">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
                    </button>
                </div>
            `;
            container.appendChild(div);
            
            // Trigger animation
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    div.classList.remove('opacity-0', 'translate-y-2', 'max-h-0');
                    div.classList.add('max-h-20');
                });
            });
            
            setupLongPressDrag(div);
            
            const inputs = div.querySelectorAll('input');
            inputs.forEach(input => {
                input.addEventListener('input', updateExercisesFromUI);
                
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.target.blur();
                    }
                });
                
                // Add blur handler for time formatting
                if (input.classList.contains('exercise-duration-input')) {
                    input.addEventListener('blur', function() {
                        const val = this.value.trim();
                        if (val) {
                            const seconds = parseTimeInput(val);
                            this.value = seconds > 0 ? formatToMMSS(seconds) : '';
                        }
                        updateExercisesFromUI();
                    });
                }
            });
        }

        function addNewExerciseRow() {
            createExerciseRow('', '');
            updateExercisesFromUI();
        }

        function removeExerciseRow(btn) {
            const row = btn.closest('.exercise-row');
            
            // Set explicit height for transition
            row.style.maxHeight = row.scrollHeight + 'px';
            row.classList.add('overflow-hidden');
            void row.offsetWidth; // Force reflow

            // Exit animation
            row.style.maxHeight = '0px';
            row.classList.add('opacity-0', '-translate-y-2', '!mt-0', '!mb-0', 'pointer-events-none');
            
            setTimeout(() => {
                row.remove();
                updateExercisesFromUI();
                
                // Ensure we don't leave an empty list
                if (document.getElementById('exercises-list').children.length === 0) {
                    addNewExerciseRow();
                }
            }, 300);
        }

        // ============================================
        // DRAG AND DROP REORDERING
        // ============================================
        let draggingRow = null;
        let ghost = null;
        let dragOffsetY = 0;
        let dragFrameId = null;

        function setupLongPressDrag(element) {
            let timer = null;
            let startX = 0;
            let startY = 0;

            const handleStart = (e) => {
                if (e.target.closest('.delete-btn')) return;
                
                const isInput = e.target.tagName === 'INPUT';
                const isTouch = e.type.startsWith('touch');
                
                // If mouse and not input, drag immediately
                if (!isTouch && !isInput) {
                     const clientX = e.clientX;
                     const clientY = e.clientY;
                     startDrag(element, clientX, clientY, e);
                     e.preventDefault(); 
                     return;
                }
                
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                
                startX = clientX;
                startY = clientY;

                timer = setTimeout(() => {
                    startDrag(element, startX, startY, e);
                }, 300);
            };

            const handleMove = (e) => {
                if (!timer) return;
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                
                if (Math.abs(clientX - startX) > 10 || Math.abs(clientY - startY) > 10) {
                    clearTimeout(timer);
                    timer = null;
                }
            };

            const handleEnd = () => {
                if (timer) {
                    clearTimeout(timer);
                    timer = null;
                }
            };

            element.addEventListener('touchstart', handleStart, {passive: true});
            element.addEventListener('touchmove', handleMove, {passive: true});
            element.addEventListener('touchend', handleEnd);
            
            element.addEventListener('mousedown', handleStart);
            element.addEventListener('mousemove', handleMove);
            element.addEventListener('mouseup', handleEnd);
            element.addEventListener('mouseleave', handleEnd);
        }

        function startDrag(row, clientX, clientY, originalEvent) {
            draggingRow = row;
            
            const rect = row.getBoundingClientRect();
            dragOffsetY = clientY - rect.top;
            
            // Create Ghost
            ghost = row.cloneNode(true);
            ghost.classList.add('ghost');
            ghost.style.width = rect.width + 'px';
            ghost.style.height = rect.height + 'px';
            ghost.style.top = rect.top + 'px';
            ghost.style.left = rect.left + 'px';
            
            // Disable inputs in ghost
            ghost.querySelectorAll('input').forEach(i => i.setAttribute('disabled', 'true'));
            
            document.body.appendChild(ghost);
            
            row.classList.add('placeholder');
            
            // Vibration
            if (navigator.vibrate) navigator.vibrate(50);
            
            document.body.style.overflow = 'hidden';
            
            if (originalEvent.type.startsWith('touch')) {
                document.addEventListener('touchmove', onDragMove, {passive: false});
                document.addEventListener('touchend', onDragEnd);
            } else {
                document.addEventListener('mousemove', onDragMove);
                document.addEventListener('mouseup', onDragEnd);
            }
        }

        function onDragMove(e) {
            if (!draggingRow || !ghost) return;
            if (e.type === 'touchmove') e.preventDefault();
            
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            
            // Move Ghost
            // Move Ghost immediately for responsiveness
            ghost.style.top = (clientY - dragOffsetY) + 'px';
            
            // Throttle heavy layout calculations
            if (dragFrameId) return;
            
            dragFrameId = requestAnimationFrame(() => {
                handleDragReorder(clientX, clientY);
                dragFrameId = null;
            });
        }

        function handleDragReorder(clientX, clientY) {
            const elementBelow = document.elementFromPoint(clientX, clientY);
            if (!elementBelow) return;
            
            const rowBelow = elementBelow.closest('.exercise-row');
            
            if (rowBelow && rowBelow !== draggingRow) {
                const container = document.getElementById('exercises-list');
                const rows = Array.from(container.children);
                
                const draggingIndex = rows.indexOf(draggingRow);
                const targetIndex = rows.indexOf(rowBelow);
                
                // Calculate threshold to prevent flickering
                const targetRect = rowBelow.getBoundingClientRect();
                const targetMiddleY = targetRect.top + targetRect.height / 2;
                const isMovingDown = draggingIndex < targetIndex;
                
                // Only swap if we have crossed the midline of the target element
                if (isMovingDown && clientY < targetMiddleY) return;
                if (!isMovingDown && clientY > targetMiddleY) return;

                // FLIP Animation: Capture old positions
                const positions = new Map();
                rows.forEach(r => positions.set(r, r.getBoundingClientRect().top));

                if (isMovingDown) {
                    container.insertBefore(draggingRow, rowBelow.nextSibling);
                } else {
                    container.insertBefore(draggingRow, rowBelow);
                }
                
                // FLIP Animation: Play
                rows.forEach(r => {
                    if (r === draggingRow) return; // Don't animate placeholder
                    const oldTop = positions.get(r);
                    const newTop = r.getBoundingClientRect().top;
                    
                    if (oldTop && newTop && oldTop !== newTop) {
                        const delta = oldTop - newTop;
                        r.style.transition = 'none';
                        r.style.transform = `translateY(${delta}px)`;
                        
                        requestAnimationFrame(() => {
                            r.style.transition = 'transform 0.3s ease';
                            r.style.transform = '';
                        });
                    }
                });
            }
        }

        function onDragEnd(e) {
            if (draggingRow && ghost) {
                // Animate ghost to final position
                const rect = draggingRow.getBoundingClientRect();
                ghost.style.transition = 'top 0.2s ease, left 0.2s ease';
                ghost.style.top = rect.top + 'px';
                ghost.style.left = rect.left + 'px';
                
                setTimeout(() => {
                    if (ghost) ghost.remove();
                    if (draggingRow) draggingRow.classList.remove('placeholder');
                    ghost = null;
                    draggingRow = null;
                    updateExercisesFromUI();
                }, 200);
            } else {
                draggingRow = null;
            }
            
            document.body.style.overflow = '';
            
            document.removeEventListener('touchmove', onDragMove);
            document.removeEventListener('touchend', onDragEnd);
            document.removeEventListener('mousemove', onDragMove);
            document.removeEventListener('mouseup', onDragEnd);
            
            if (dragFrameId) {
                cancelAnimationFrame(dragFrameId);
                dragFrameId = null;
            }
        }

        function updateExercisesFromUI() {
            const container = document.getElementById('exercises-list');
            const rows = container.querySelectorAll('.exercise-row');
            const newExercises = [];
            
            rows.forEach(row => {
                const nameInput = row.querySelector('.exercise-name-input');
                const durInput = row.querySelector('.exercise-duration-input');
                let name = nameInput.value.trim();
                let durationVal = durInput.value.trim();
                
                // Allow empty names so the row isn't lost in data model
                newExercises.push({ name: name, duration: durationVal ? parseTimeInput(durationVal) : null });
            });
            
            exercisesData = newExercises;
            
            saveSettings();
            updateTotalTimeDisplay();
            updateCountsDisplay();
        }

        // ============================================
        // TIME INPUT HELPERS (MM:SS format)
        // ============================================
        function parseTimeInput(value) {
            // Remove any spaces
            value = value.trim();
            
            // If contains colon, parse as MM:SS
            if (value.includes(':')) {
                const parts = value.split(':');
                const min = parseInt(parts[0]) || 0;
                const sec = parseInt(parts[1]) || 0;
                return min * 60 + sec;
            }
            
            // Otherwise treat as seconds
            return parseInt(value) || 0;
        }

        function formatToMMSS(seconds) {
            seconds = Math.max(0, seconds); // No negatives
            const min = Math.floor(seconds / 60);
            const sec = seconds % 60;
            return `${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;
        }

        function handleTimeBlur(inputId) {
            const input = document.getElementById(inputId);
            const seconds = parseTimeInput(input.value);
            input.setAttribute('data-seconds', seconds);
            input.value = formatToMMSS(seconds);
            
            // Trigger save and update
            saveSettings();
            updateTotalTimeDisplay();
        }

        function getSecondsFromTimeInput(inputId) {
            const input = document.getElementById(inputId);
            return parseInt(input.getAttribute('data-seconds')) || 0;
        }

        function setTimeInputSeconds(inputId, seconds) {
            const input = document.getElementById(inputId);
            seconds = Math.max(0, seconds);
            input.setAttribute('data-seconds', seconds);
            input.value = formatToMMSS(seconds);
            
            // Trigger save and update
            input.dispatchEvent(new Event('input'));
        }

        // ============================================
        // INCREMENT/DECREMENT WITH LONG-PRESS (for time inputs)
        // ============================================
        let adjustmentInterval = null;
        let adjustmentTimeout = null;
        let speedUpTimeout = null;
        let isAdjusting = false; // Prevent double-fire on mobile
        
        // New state variables for scroll vs. tap detection
        let tapTimeout = null;
        let isScrolling = false;
        let touchStartY = 0;

        function incrementTimeValue(inputId) { // +5 seconds
            const seconds = getSecondsFromTimeInput(inputId);
            setTimeInputSeconds(inputId, seconds + 5);
            
            // Haptic feedback on mobile
            if (navigator.vibrate) {
                navigator.vibrate(10);
            }
        }

        function decrementTimeValue(inputId) { // -5 seconds
            const seconds = getSecondsFromTimeInput(inputId);
            setTimeInputSeconds(inputId, seconds - 5);
            
            // Haptic feedback on mobile
            if (navigator.vibrate) {
                navigator.vibrate(10);
            }
        }

        function startAdjustment(actionFn) {
            // Don't start a new adjustment if one is in progress or if we are scrolling
            if (isAdjusting || isScrolling) return;
            isAdjusting = true;

            const performActionAndHold = () => {
                actionFn(); // Perform the first action

                // Set up the long-press timer to repeat the action
                adjustmentTimeout = setTimeout(() => {
                    adjustmentInterval = setInterval(actionFn, 150); // Repeat every 150ms
                    
                    // Speed up after 2 seconds
                    speedUpTimeout = setTimeout(() => {
                        clearInterval(adjustmentInterval);
                        adjustmentInterval = setInterval(actionFn, 75); // Repeat faster
                    }, 2000);
                }, 420); // Wait 420ms after the first action to start repeating (total ~500ms)
            };

            // Set a short timeout. If it's not cleared by a scroll, we consider it a tap/hold.
            tapTimeout = setTimeout(performActionAndHold, 80);
        }

        function startTimeIncrement(inputId, event) {
            startAdjustment(() => incrementTimeValue(inputId));
        }

        function startTimeDecrement(inputId, event) {
            startAdjustment(() => decrementTimeValue(inputId));
        }

        function stopAdjustment() {
            clearTimeout(adjustmentTimeout);
            clearTimeout(speedUpTimeout);
            clearInterval(adjustmentInterval);
            isAdjusting = false;
        }

        function cancelAllAdjustments() {
            clearTimeout(tapTimeout);
            tapTimeout = null;
            stopAdjustment();
        }

        // ============================================
        // CIRCUITS INCREMENT/DECREMENT (still uses +/- 1)
        // ============================================
        function incrementValue(inputId) {
            const input = document.getElementById(inputId);
            const currentValue = parseInt(input.value) || 0;
            const min = parseInt(input.min) || 0;
            const max = parseInt(input.max) || 999;
            
            if (currentValue < max) {
                input.value = currentValue + 1;
                input.dispatchEvent(new Event('input'));
                
                if (navigator.vibrate) {
                    navigator.vibrate(10);
                }
            }
        }

        function decrementValue(inputId) {
            const input = document.getElementById(inputId);
            const currentValue = parseInt(input.value) || 0;
            const min = parseInt(input.min) || 0;
            
            if (currentValue > min) {
                input.value = currentValue - 1;
                input.dispatchEvent(new Event('input'));
                
                if (navigator.vibrate) {
                    navigator.vibrate(10);
                }
            }
        }

        function startIncrement(inputId) {
            startAdjustment(() => incrementValue(inputId));
        }

        function startDecrement(inputId) {
            startAdjustment(() => decrementValue(inputId));
        }


        function switchTab(tab) {
            const timerView = document.getElementById('view-timer');
            const settingsView = document.getElementById('view-settings');

            if (tab === 'timer') {
                settingsView.classList.remove('active');
                timerView.classList.add('active');
                updateTotalTimeDisplay();
            } else {
                timerView.classList.remove('active');
                settingsView.classList.add('active');
                if (timer && !isPaused) togglePause();
            }
        }

        function toggleMute() { 
            voiceEnabled = !voiceEnabled; 
            handleMuteToggle(voiceEnabled);
            saveSettings();
        }
        
        function handleMuteToggle(isUnmuted) {
            if (isUnmuted) { 
                btnMute.classList.remove('is-muted'); 
                iconMuted.classList.add('hidden'); 
                iconUnmuted.classList.remove('hidden'); 
            } else { 
                btnMute.classList.add('is-muted'); 
                iconMuted.classList.remove('hidden'); 
                iconUnmuted.classList.add('hidden'); 
                speechManager.cancel();
            }
        }
        
        function speak(text) {
            if (!voiceEnabled) return;

            if (audioType === 'beep') {
                const num = parseInt(text);
                if (!isNaN(num)) {
                    soundManager.playCountdown();
                } else if (/Rest/.test(text)) {
                    soundManager.playRestStart();
                } else if (/Begin|Start/.test(text)) {
                    soundManager.playWorkStart();
                } else if (/complete|amazing/i.test(text)) {
                    soundManager.playComplete();
                } else {
                    // Default fallback
                    soundManager.playRestStart();
                }
            } else {
                // Use voice
                speechManager.speak(text, voiceEnabled);
            }
        }
        
        function updateProgress(percent) { 
            // Direct update for smooth animation via requestAnimationFrame
            progressCircle.style.strokeDashoffset = CIRCUMFERENCE - (percent / 100 * CIRCUMFERENCE);
        }

        function refillProgress() {
            // Temporarily enable transition for smooth refill
            progressCircle.style.transition = 'stroke-dashoffset 0.05s ease-out, stroke 0.4s ease';
            
            // Set to full
            progressCircle.style.strokeDashoffset = '0';
            
            // Remove transition after animation
            setTimeout(() => {
                progressCircle.style.transition = 'stroke 0.4s ease';
            }, 50);
        }

        function formatTime(seconds) { return `${Math.floor(seconds / 60).toString().padStart(2, '0')}:${(seconds % 60).toString().padStart(2, '0')}`; }
        function parseExercises() { 
            const defaultWork = getSecondsFromTimeInput('input-work'); 
            return exercisesData.map((item, index) => { 
                return { 
                    name: item.name || `Exercise ${index + 1}`, 
                    duration: item.duration || defaultWork 
                }; 
            }); 
        }
        
        function calculateTotalTime() {
            const exercises = parseExercises();
            if (exercises.length === 0) return 0;
            
            const circuits = parseInt(inputRounds.value);
            const restTime = getSecondsFromTimeInput('input-rest');
            const prepTime = getSecondsFromTimeInput('input-prepare');
            const coolDownTime = getSecondsFromTimeInput('input-cooldown');
            
            let totalWorkTime = 0;
            exercises.forEach(ex => {
                totalWorkTime += ex.duration;
            });
            
            const totalTime = prepTime + (totalWorkTime * circuits) + (restTime * (exercises.length * circuits - 1)) + coolDownTime;
            
            return totalTime;
        }
        
        function updateProgressBar(time, isRunning) {
            if (!totalProgressBar) return;

            let progress;
            if (isRunning) {
                // Smoothly update based on precise time remaining
                progress = (initialTotalTime > 0) ? (time / initialTotalTime) * 100 : 0;
            } else {
                // Set static state: 100% if a workout is configured, 0% otherwise
                progress = (time > 0) ? 100 : 0;
            }
            totalProgressBar.style.width = `${Math.max(0, Math.min(100, progress))}%`;
        }

        function updateTotalTimeDisplay(secondsOverride = null) {
            // If a specific time is provided (during workout), use it. 
            // Otherwise calculate from settings (during setup).
            const totalSeconds = secondsOverride !== null ? secondsOverride : calculateTotalTime();
            
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            totalTimeDisplayEl.innerText = `Total: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            // Hide total time if 0 and not currently running a workout (setup mode)
            if (secondsOverride === null && totalSeconds === 0) {
                totalTimeDisplayEl.classList.add('opacity-0');
                if (totalProgressBarContainer) totalProgressBarContainer.classList.add('opacity-0');
            } else {
                totalTimeDisplayEl.classList.remove('opacity-0');
                if (totalProgressBarContainer) totalProgressBarContainer.classList.remove('opacity-0');
            }

            // Update Total Progress Bar only when timer is NOT running.
            // When timer is running, it's handled by updateProgressBarOnly on each frame.
            if (!timer && !isPaused) { updateProgressBar(totalSeconds, false); }
        }
        
        function updateCountsDisplay() {
            const exercises = parseExercises();
            const totalCircuits = parseInt(inputRounds.value) || 1;
            const count = exercises.length || 0;
            
            // Always show the counts based on current settings
            if (count > 0) {
                roundDisplayEl.innerText = `Exercise 1 / ${count}`;
                circuitDisplayEl.innerText = `Circuit 1 / ${totalCircuits}`;
            } else {
                roundDisplayEl.innerText = 'Add Exercises';
                circuitDisplayEl.innerText = ' ';
            }
            
            // Show first exercise as "Next" when stopped
            if (!timer && !isPaused) {
                if (count > 0) {
                    nextExerciseNameEl.innerText = exercises[0].name;
                    nextUpContainer.classList.remove('opacity-0');
                    nextUpContainer.classList.add('opacity-100');
                } else {
                    nextUpContainer.classList.remove('opacity-100');
                    nextUpContainer.classList.add('opacity-0');
                }
            }
        }
        
        function getIntervalData(index) { 
            const listSize = exerciseObjects.length; 
            if (listSize === 0) return null; 
            return { 
                exercise: exerciseObjects[index % listSize], 
                exerciseNum: (index % listSize) + 1, 
                circuitNum: Math.floor(index / listSize) + 1, 
                isLastOverall: (index === (listSize * parseInt(inputRounds.value)) - 1) 
            }; 
        }

        const phaseStyles = {
            prepare: { circle: 'text-blue-500', text: 'text-blue-400', bar: 'bg-blue-500', shadow: 'shadow-[0_0_10px_rgba(59,130,246,0.5)]' },
            work:    { circle: 'text-emerald-500', text: 'text-emerald-400', bar: 'bg-emerald-500', shadow: 'shadow-[0_0_10px_rgba(16,185,129,0.5)]' },
            rest:    { circle: 'text-orange-500', text: 'text-orange-400', bar: 'bg-orange-500', shadow: 'shadow-[0_0_10px_rgba(245,158,11,0.5)]' },
            cooldown:{ circle: 'text-teal-500', text: 'text-teal-400', bar: 'bg-teal-500', shadow: 'shadow-[0_0_10px_rgba(20,184,166,0.5)]' },
        };
        const allCircleClasses = Object.values(phaseStyles).map(s => s.circle);
        const allTextClasses = Object.values(phaseStyles).map(s => s.text);
        const allBarClasses = Object.values(phaseStyles).map(s => s.bar);
        const allShadowClasses = Object.values(phaseStyles).map(s => s.shadow);

        function setVisualState(phase, instant = false) {
            if (instant) { progressCircle.style.transition = 'none'; }

            const style = phaseStyles[phase];
            if (style) {
                progressCircle.classList.remove(...allCircleClasses, 'text-yellow-300', 'text-yellow-400');
                progressCircle.classList.add(style.circle);
                
                exerciseTextEl.classList.remove(...allTextClasses, 'text-yellow-300', 'text-yellow-400');
                exerciseTextEl.classList.add(style.text);

                totalProgressBar.classList.remove(...allBarClasses, ...allShadowClasses, 'bg-yellow-300', 'shadow-[0_0_10px_rgba(253,224,71,0.5)]');
                totalProgressBar.classList.add(style.bar, style.shadow);
            }

            if (phase === 'prepare') {
                exerciseTextEl.innerText = "Get Ready";
                const info = getIntervalData(0);
                roundDisplayEl.innerText = `Exercise ${info.exerciseNum} / ${exerciseObjects.length}`;
                circuitDisplayEl.innerText = `Circuit ${info.circuitNum} / ${inputRounds.value}`;
                nextExerciseNameEl.innerText = info.exercise.name;
                nextUpContainer.classList.replace('opacity-0', 'opacity-100');
                speak(`Get ready. First, ${info.exercise.name}.`);
            } else if (phase === 'rest') {
                exerciseTextEl.innerText = "Rest";
                const info = getIntervalData(globalIntervalIndex + 1);
                nextExerciseNameEl.innerText = info.exercise.name;
                nextUpContainer.classList.replace('opacity-0', 'opacity-100');
                speak(`Rest. Next is ${info.exercise.name}.`);
            } else if (phase === 'cooldown') {
                exerciseTextEl.innerText = "Cool Down";
                roundDisplayEl.innerText = "Cool Down";
                nextExerciseNameEl.innerText = "Complete";
                nextUpContainer.classList.replace('opacity-0', 'opacity-100');
                speak("Cool Down");
            } else {
                const info = getIntervalData(globalIntervalIndex);
                exerciseTextEl.innerText = info.exercise.name;
                roundDisplayEl.innerText = `Exercise ${info.exerciseNum} / ${exerciseObjects.length}`;
                circuitDisplayEl.innerText = `Circuit ${info.circuitNum} / ${inputRounds.value}`;
                
                if (!info.isLastOverall) {
                    nextExerciseNameEl.innerText = "Rest";
                    nextUpContainer.classList.replace('opacity-0', 'opacity-100');
                } else {
                    nextUpContainer.classList.replace('opacity-100', 'opacity-0');
                }
                speak(info.exercise.name + ". Begin.");
                //speak(info.exercise.name + ". Start.");
            }

            if (instant) { progressCircle.style.transition = ''; }
        }

        function runTimerLoop() {
            if (isPaused) return;
            
            timer = requestAnimationFrame(runTimerLoop);
            
            const now = Date.now();
            const timeLeftMs = phaseEndTime - now;
            
            if (timeLeftMs <= 0) {
                cancelAnimationFrame(timer);
                nextPhase();
                return;
            }

            // Smooth progress update
            const percent = (timeLeftMs / (totalPhaseSeconds * 1000)) * 100;
            updateProgress(percent);

            // Integer second updates for text display
            const currentSeconds = Math.ceil(timeLeftMs / 1000);
            if (currentSeconds !== secondsRemaining) {
                secondsRemaining = currentSeconds;
                timeLeftEl.innerText = formatTime(secondsRemaining);
                
                if (totalTimeRemaining > 0) totalTimeRemaining--;
                updateTotalTimeDisplay(totalTimeRemaining); // Update text and non-timer bar state
                
                if (secondsRemaining <= 3 && secondsRemaining > 0) {
                    speak(secondsRemaining.toString());
                }
            }
            const preciseTotalTime = workoutEndTime > 0 ? (workoutEndTime - Date.now()) / 1000 : 0;
            updateProgressBar(preciseTotalTime, true);
        }

        function nextPhase(isManualSkip = false) {
            if (!timer) return;
            // If manually skipping, cancel current loop frame to prevent double-fire
            if (timer) cancelAnimationFrame(timer);
            
            // If this is a natural transition (not a manual skip), the last second just ended.
            // We need to decrement the total time to account for it before starting the next phase.
            if (!isManualSkip && totalTimeRemaining > 0) {
                totalTimeRemaining--;
            }

            // If skipping manually, deduct precise time left in current phase
            if (isManualSkip) {
                let timeToSkip = 0;
                if (isPaused) {
                    timeToSkip = pausedTimeRemainingMs;
                } else {
                    timeToSkip = Math.max(0, phaseEndTime - Date.now());
                }

                if (timeToSkip > 0) {
                    workoutEndTime -= timeToSkip;
                    
                    // Update integer display
                    const skippedSeconds = Math.ceil(timeToSkip / 1000);
                    totalTimeRemaining = Math.max(0, totalTimeRemaining - skippedSeconds);
                    updateTotalTimeDisplay(totalTimeRemaining);

                    // Force update progress bar immediately
                    const preciseTotalTime = Math.max(0, (workoutEndTime - Date.now()) / 1000);
                    updateProgressBar(preciseTotalTime, true);
                }
            }
            
            if (currentPhase === 'prepare') { currentPhase = 'work'; globalIntervalIndex = 0; totalPhaseSeconds = getIntervalData(0).exercise.duration; }
            else if (currentPhase === 'work') { 
                if (getIntervalData(globalIntervalIndex).isLastOverall) { 
                    const coolDown = getSecondsFromTimeInput('input-cooldown');
                    if (coolDown > 0) {
                        currentPhase = 'cooldown';
                        totalPhaseSeconds = coolDown;
                    } else {
                        completeWorkout(); return; 
                    }
                } else { currentPhase = 'rest'; totalPhaseSeconds = getSecondsFromTimeInput('input-rest'); }
            }
            else if (currentPhase === 'cooldown') { completeWorkout(); return; }
            else { globalIntervalIndex++; currentPhase = 'work'; totalPhaseSeconds = getIntervalData(globalIntervalIndex).exercise.duration; } // Rest -> Work
            secondsRemaining = totalPhaseSeconds;
            
            setVisualState(currentPhase, isManualSkip);
            timeLeftEl.innerText = formatTime(secondsRemaining);
            refillProgress();
            
            if (!isPaused) {
                phaseEndTime = Date.now() + (totalPhaseSeconds * 1000);
                runTimerLoop();
            } else {
                // If paused, prepare the time for when we eventually resume
                pausedTimeRemainingMs = totalPhaseSeconds * 1000;
            }
        }

        async function startWorkout() {
            exerciseObjects = parseExercises();
            if (exerciseObjects.length === 0) {
                // If no exercises, add one so the user can start
                addNewExerciseRow();
                return;
            }
            
            // Clean up any completion animations from previous workout
            exerciseTextEl.classList.remove('pulse-text', 'text-yellow-300', 'text-yellow-400');
            progressCircle.classList.remove('pulse-circle-stroke', 'text-yellow-300', 'text-yellow-400');
            
            // Remove completion glow if it exists
            const completionGlow = document.getElementById('completion-glow');
            if (completionGlow) completionGlow.remove();
            
            await wakeLockManager.enable();
            
            const prep = getSecondsFromTimeInput('input-prepare');
            isPaused = false;
            currentPhase = prep > 0 ? 'prepare' : 'work';
            totalPhaseSeconds = prep > 0 ? prep : getIntervalData(0).exercise.duration;
            secondsRemaining = totalPhaseSeconds;
            phaseEndTime = Date.now() + (totalPhaseSeconds * 1000);
            totalTimeRemaining = calculateTotalTime(); // Initialize total countdown
            initialTotalTime = totalTimeRemaining; // Store initial total for progress bar
            workoutEndTime = Date.now() + (initialTotalTime * 1000);
            
            timeLeftEl.innerText = formatTime(secondsRemaining); 
            updateProgress(100); // Set initial progress to full
            
            setVisualState(currentPhase);
            btnStart.classList.add('hidden');
            btnPause.classList.remove('hidden');
            
            // Start timer AFTER displaying initial state
            if (timer) cancelAnimationFrame(timer);
            runTimerLoop();
            switchTab('timer');
        }

        async function togglePause() { 
            if (!timer) return; 
            isPaused = !isPaused; 
            
            if (isPaused) {
                cancelAnimationFrame(timer);
                // Calculate exact remaining time to preserve precision
                pausedTimeRemainingMs = phaseEndTime - Date.now();
                pauseStartTime = Date.now();
                
                await wakeLockManager.disable();
                speechManager.cancel();
                btnStart.innerText = "Resume";
            } else {
                // Resume using exact stored time
                phaseEndTime = Date.now() + pausedTimeRemainingMs;
                if (pauseStartTime > 0) {
                    const pauseDuration = Date.now() - pauseStartTime;
                    workoutEndTime += pauseDuration;
                    pauseStartTime = 0;
                }
                await wakeLockManager.enable();
                runTimerLoop();
            }
            
            btnStart.classList.toggle('hidden', !isPaused); 
            btnPause.classList.toggle('hidden', isPaused); 
        }
        
        async function completeWorkout() { 
            if (timer) cancelAnimationFrame(timer);
            timer = null; 
            
            await wakeLockManager.disable();

            // Set final time to 00:00
            totalTimeRemaining = 0;
            updateTotalTimeDisplay(totalTimeRemaining);
            
            // Visual celebration - synchronized pulsing
            
            // Change text to soft pastel yellow
            exerciseTextEl.innerText = "Amazing!"; 
            exerciseTextEl.classList.remove(...allTextClasses);
            exerciseTextEl.classList.add('text-yellow-300');
            
            // Add pulsing to text
            exerciseTextEl.classList.add('pulse-text');
            
            // Make the circle full (100%) so entire circle glows
            refillProgress();
            
            // Make progress circle pulse
            progressCircle.classList.add('pulse-circle-stroke');
            
            // Add circular radial glow behind the circle - soft pastel yellow
            const progressContainer = document.querySelector('.progress-svg-container');
            const glowDiv = document.createElement('div');
            glowDiv.className = 'pulse-radial-glow';
            glowDiv.id = 'completion-glow';
            progressContainer.insertBefore(glowDiv, progressContainer.firstChild);
            
            // Vibration feedback (if supported)
            if (navigator.vibrate) {
                navigator.vibrate([200, 100, 200, 100, 200]);
            }
            
            // Make progress circle soft yellow for completion
            progressCircle.classList.remove(...allCircleClasses, 'text-yellow-400');
            progressCircle.classList.add('text-yellow-300');

            // Make total progress bar yellow and full to signify 100% completion
            totalProgressBar.classList.remove(...allBarClasses, ...allShadowClasses);
            totalProgressBar.classList.add('bg-yellow-300', 'shadow-[0_0_10px_rgba(253,224,71,0.5)]');
            totalProgressBar.style.width = '100%';
            
            nextUpContainer.classList.replace('opacity-100', 'opacity-0');
            btnStart.innerText = "Start";
            btnStart.classList.remove('hidden'); 
            btnPause.classList.add('hidden'); 
            speak("Workout complete! Great job!"); 
        }

        // ============================================
        // SOFT RESET FUNCTION (No Page Reload)
        // ============================================
        async function resetTimer() {
            console.log('ðŸ”„ Soft reset initiated');
            
            // Stop and clear timer
            if (timer) {
                cancelAnimationFrame(timer);
                timer = null;
            }
            
            // Cleanup resources
            await wakeLockManager.disable();
            speechManager.cancel();
            
            // Reset all state variables
            isPaused = false;
            currentPhase = 'prepare';
            globalIntervalIndex = 0;
            secondsRemaining = 0;
            totalPhaseSeconds = 0;
            initialTotalTime = 0;
            workoutEndTime = 0;
            pauseStartTime = 0;
            exerciseObjects = [];
            
            // Reset UI - Status and Exercise
            exerciseTextEl.innerText = 'Get Ready';
            exerciseTextEl.classList.remove(...allTextClasses, 'text-yellow-300', 'text-yellow-400', 'pulse-text');
            exerciseTextEl.classList.add('text-blue-400');
            
            timeLeftEl.innerText = '00:00';
            updateCountsDisplay();
            
            // Reset total time display
            updateTotalTimeDisplay(); // Instant update for reset
            
            // Reset buttons
            btnStart.innerText = "Start";
            btnStart.classList.remove('hidden');
            btnPause.classList.add('hidden');
            
            // Reset progress circle
            progressCircle.classList.remove(...allCircleClasses, 'text-yellow-400', 'text-yellow-300', 'pulse-circle-stroke');
            progressCircle.classList.add('text-blue-500');
            updateProgress(100);

            // Reset total progress bar
            totalProgressBar.classList.remove(...allBarClasses, ...allShadowClasses, 'bg-yellow-300', 'shadow-[0_0_10px_rgba(253,224,71,0.5)]');
            totalProgressBar.classList.add('bg-blue-500', 'shadow-[0_0_10px_rgba(59,130,246,0.5)]');
            
            // Remove celebration glow
            const completionGlow = document.getElementById('completion-glow');
            if (completionGlow) completionGlow.remove();
            
            // Switch to timer tab
            switchTab('timer');
            
            console.log('âœ“ Reset complete');
        }

        btnStart.addEventListener('click', async () => {
            // Initialize speech FIRST (must be synchronous in user gesture for iOS)
            speechManager.initialize();
            await soundManager.unlock();

            if (timer && isPaused) {
                togglePause();
            } else {
                startWorkout();
            }
        });
        btnPause.addEventListener('click', togglePause);
        document.getElementById('btn-reset').addEventListener('click', resetTimer);

        // Handle page visibility changes to pause/resume timer automatically
        document.addEventListener('visibilitychange', () => {
            // If timer is not running, or if it's explicitly paused by the user, do nothing.
            if (!timer || isPaused) {
                return;
            }

            if (document.hidden) {
                // Page is hidden: Implicitly pause the timer.
                // Cancel the animation loop and store the exact time when it was hidden.
                cancelAnimationFrame(timer);
                pausedTimeRemainingMs = Math.max(0, phaseEndTime - Date.now());
                pauseStartTime = Date.now();
                console.log('Page hidden, timer paused implicitly.');
            } else {
                // Page is visible: Implicitly resume the timer if it was running.
                // Check if pauseStartTime was set, which indicates an implicit pause.
                if (pauseStartTime > 0) {
                    const pauseDuration = Date.now() - pauseStartTime;
                    
                    // Adjust the master workout end time and current phase end time
                    workoutEndTime += pauseDuration;
                    phaseEndTime = Date.now() + pausedTimeRemainingMs;
                    
                    pauseStartTime = 0;
                    runTimerLoop();
                    console.log('Page visible, timer resumed implicitly.');
                }
            }
        });

        // Keyboard Shortcuts
        document.addEventListener('keydown', (e) => {
            // Ignore shortcuts if user is typing in an input field
            if (e.target.tagName === 'INPUT') return;

            switch(e.code) {
                case 'Space':
                    e.preventDefault(); // Prevent scrolling
                    if (timer || isPaused) {
                        togglePause();
                    } else {
                        speechManager.initialize();
                        soundManager.unlock().then(() => {
                            startWorkout();
                        });
                    }
                    break;
                case 'KeyR':
                    resetTimer();
                    break;
                case 'KeyM':
                    toggleMute();
                    break;
                case 'ArrowRight':
                    if (timer && !isPaused) nextPhase(true);
                    break;
            }
        });

        // Generic Pointer Events Handler for consistent button feedback across iOS/Android/PC
        document.addEventListener('pointerdown', (e) => {
            const btn = e.target.closest('.ios-button');
            if (!btn) return;

            btn.classList.add('is-pressed');
            try { btn.setPointerCapture(e.pointerId); } catch(e){}

            const clear = (e) => {
                btn.classList.remove('is-pressed');
                try { btn.releasePointerCapture(e.pointerId); } catch(e){}
                ['pointerup', 'pointercancel', 'pointerleave', 'lostpointercapture'].forEach(evt => {
                    btn.removeEventListener(evt, clear);
                });
            };
            
            ['pointerup', 'pointercancel', 'pointerleave', 'lostpointercapture'].forEach(evt => {
                btn.addEventListener(evt, clear);
            });
        });

        // Add listeners to differentiate between a tap and a scroll on touch devices
        window.addEventListener('touchstart', (e) => {
            // Reset scroll detection on a new touch
            isScrolling = false;
            touchStartY = e.touches[0].clientY;
        }, { passive: true });

        window.addEventListener('touchmove', (e) => {
            // If the touch has moved more than 10px vertically, it's a scroll
            if (Math.abs(e.touches[0].clientY - touchStartY) > 10) {
                if (!isScrolling) { // Only trigger once per scroll
                    isScrolling = true;
                    // A scroll should cancel any pending button press
                    cancelAllAdjustments();
                }
            }
        }, { passive: true });

        progressCircle.style.strokeDasharray = `${CIRCUMFERENCE} ${CIRCUMFERENCE}`;
        window.onload = () => {
            loadRoutines();
            loadSettings();
            renderExerciseList();
            setupAutoSave();
            timeLeftEl.innerText = formatTime(0);
            updateTotalTimeDisplay();
            updateCountsDisplay();
        };

        window.addEventListener('beforeunload', async () => {
            await wakeLockManager.disable();
            speechManager.cancel();
        });

        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            const dropdown = document.getElementById('custom-routine-dropdown');
            if (dropdown && !dropdown.contains(e.target)) {
                toggleDropdown(false);
            }
        });
    </script>
</body>
</html>
