<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Interval Timer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --system-blue: #007AFF;
            --system-emerald: #10b981;
            --system-orange: #f59e0b;
            --system-background: #000000;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background-color: var(--system-background);
            background-image: 
                radial-gradient(at 0% 0%, rgba(0, 122, 255, 0.15) 0px, transparent 50%),
                radial-gradient(at 100% 100%, rgba(88, 86, 214, 0.15) 0px, transparent 50%);
            color: #FFFFFF;
            overflow: hidden;
            height: 100dvh;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        .apple-glass {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(30px);
            border: 1px solid rgba(255, 255, 255, 0.15);
        }

        .view-stack {
            position: relative;
            flex: 1;
            width: 100%;
            min-height: 0;
        }

        .tab-view {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black; 
            display: none; 
            flex-direction: column;
            overflow-y: auto;
            z-index: 1;
        }

        .tab-view.active {
            display: flex;
            z-index: 2;
        }

        .progress-ring__circle {
            transition: stroke 0.4s ease;
            transform: rotate(-90deg);
            transform-origin: 50% 50%;
            will-change: stroke-dashoffset;
        }

        .nav-container {
            position: relative;
            display: flex;
            background: rgba(255, 255, 255, 0.06);
            border-radius: 16px;
            padding: 4px;
            margin: 0 24px 24px 24px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            flex-shrink: 0;
        }

        .tab-btn {
            position: relative;
            flex: 1;
            padding: 8px 0;
            font-size: 11px;
            font-weight: 700;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.4);
            z-index: 10;
        }

        .tab-active { color: #FFFFFF; }

        .tab-indicator {
            position: absolute;
            top: 4px;
            left: 4px;
            height: calc(100% - 8px);
            width: calc(50% - 4px);
            background: rgba(255, 255, 255, 0.12);
            border-radius: 12px;
            transition: transform 0.3s cubic-bezier(0.2, 0, 0, 1);
            z-index: 5;
        }

        .ios-button {
            transition: transform 0.2s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.2s, background-color 0.2s;
        }

        .ios-button:active, .ios-button.is-pressed { transform: scale(0.92); opacity: 0.8; }

        /* Pressed states for specific buttons */
        #btn-start.is-pressed, #btn-pause.is-pressed { background-color: #d1d5db; }
        #btn-reset.is-pressed, #btn-skip.is-pressed { background-color: rgba(255, 255, 255, 0.2); color: white; }
        #btn-mute.is-pressed { background-color: rgba(255, 255, 255, 0.15); }
        .spinner-btn.is-pressed { background-color: rgba(255, 255, 255, 0.2); color: white; }
        .add-exercise-btn.is-pressed { background-color: rgba(255, 255, 255, 0.2); color: white; }
        .delete-btn.is-pressed { background-color: rgba(239, 68, 68, 0.2); color: #f87171; }

        @keyframes pulseBig {
            0%, 100% { 
                transform: scale(1);
            }
            50% { 
                transform: scale(1.15);
            }
        }

        @keyframes pulseCircleGlow {
            0%, 100% { 
                stroke-width: 10;
                opacity: 0.7;
            }
            50% { 
                stroke-width: 12;
                opacity: 0.9;
            }
        }
        
        @keyframes pulseRadialGlow {
            0%, 100% { 
                opacity: 0.2;
                transform: scale(1);
            }
            50% { 
                opacity: 0.4;
                transform: scale(1.1);
            }
        }

        .pulse-text {
            animation: pulseBig 1s ease-in-out infinite;
        }

        .pulse-circle-stroke {
            animation: pulseCircleGlow 1s ease-in-out infinite;
        }
        
        .pulse-radial-glow {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(253, 224, 71, 0.25) 0%, rgba(253, 224, 71, 0.15) 30%, rgba(253, 224, 71, 0.06) 50%, rgba(253, 224, 71, 0.02) 70%, transparent 85%);
            animation: pulseRadialGlow 1s ease-in-out infinite;
            pointer-events: none;
            z-index: 1;
            filter: blur(12px);
        }

        @media (max-height: 700px) {
            header { padding-top: 1.5rem !important; margin-bottom: 0.5rem !important; }
            .nav-container { margin-bottom: 1rem !important; margin-left: 1.5rem !important; margin-right: 1.5rem !important; }
            #time-left { font-size: 4.5rem !important; }
            #current-exercise { font-size: 1.5rem !important; }
            .progress-svg-container { max-width: 260px !important; }
            .media-controls { margin-top: 0.5rem !important; gap: 1rem !important; }
            .exercise-label-container { height: 52px !important; }
            #view-timer { gap: 1rem !important; }
        }

        @media (max-width: 400px) {
            .progress-svg-container { 
                max-width: 340px !important; 
            }
            .exercise-label-container {
                width: 220px !important;
            }
            #current-exercise {
                font-size: 1.5rem !important;
            }
        }

        .exercise-label-container {
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 240px;
            overflow: hidden;
        }
        
        #current-exercise {
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.3;
            max-width: 100%;
            text-align: center;
            white-space: normal;
            word-break: break-word;
        }

        .exercise-row.dragging {
            opacity: 0.5;
            transform: scale(0.98);
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            pointer-events: none; /* Allows elementFromPoint to see what's underneath */
            transition: none;
        }

        .exercise-row.ghost {
            position: fixed;
            z-index: 1000;
            pointer-events: none;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            opacity: 1;
            background: #000;
            border-radius: 12px;
        }
        .exercise-row.placeholder {
            opacity: 0 !important;
        }
    </style>
</head>
<body>

    <div class="max-w-md w-full h-full flex flex-col relative overflow-hidden">
        
        <header class="flex justify-between items-center px-4 md:px-8 pt-10 mb-3 flex-shrink-0">
            <div class="flex flex-col gap-1 min-w-[140px]">
                <span class="text-[10px] font-black tracking-[0.4em] text-white/30 uppercase">Interval Timer</span>
            </div>
            <button id="btn-mute" onclick="toggleMute()" class="ios-button flex items-center justify-center p-3 h-10 w-10 rounded-2xl apple-glass border-white/5 shadow-xl">
                <svg id="icon-unmuted" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" />
                </svg>
                <svg id="icon-muted" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M18.364 18.364A9 9 0 005.636 5.636m12.728 12.728A9 9 0 015.636 5.636m12.728 12.728L5.636 5.636" />
                </svg>
            </button>
        </header>

        <nav class="nav-container">
            <button onclick="switchTab('timer')" id="tab-timer" class="tab-btn tab-active">Timer</button>
            <button onclick="switchTab('settings')" id="tab-settings" class="tab-btn">Settings</button>
            <div id="nav-indicator" class="tab-indicator"></div>
        </nav>

        <div class="view-stack">
            <div id="view-timer" class="tab-view active pb-8 flex flex-col gap-6 pt-8 justify-center">
                <div class="relative w-full flex items-center justify-center px-4">
                    <div class="progress-svg-container relative w-full max-w-[360px] aspect-square flex items-center justify-center">
                        <svg class="absolute inset-0 w-full h-full z-0" viewBox="0 0 320 320">
                            <circle class="text-white/5" stroke-width="12" stroke="currentColor" fill="transparent" r="148" cx="160" cy="160" />
                            <circle id="progress-circle" class="progress-ring__circle text-blue-500" stroke-width="12" stroke-dasharray="930" stroke-dashoffset="0" stroke-linecap="round" stroke="currentColor" fill="transparent" r="148" cx="160" cy="160" />
                        </svg>
                        <div class="relative z-10 flex flex-col items-center justify-center text-center select-none p-4 w-full">
                            <div class="exercise-label-container">
                                <span id="current-exercise" class="text-blue-400 font-black tracking-wide uppercase text-3xl">Get Ready</span>
                            </div>
                            <span id="time-left" class="text-[5rem] font-black tracking-tighter tabular-nums leading-none mt-1">00:00</span>
                            <div class="mt-3 flex flex-col items-center min-h-[68px]">
                                <span id="circuit-display" class="text-sm font-bold text-blue-500/50 uppercase tracking-[0.2em]"> </span>
                                <span id="round-display" class="text-sm font-bold text-white/30 uppercase tracking-[0.2em] mt-1">Ready</span>
                                <span id="total-time-display" class="text-sm font-bold text-white/60 uppercase tracking-[0.2em] mt-1 transition-opacity duration-300">Total: --:--</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="next-up-container" class="flex flex-col items-center justify-center opacity-0 transition-all duration-500">
                    <div class="flex items-center gap-2">
                        <span class="text-[8px] font-black text-white/20 uppercase tracking-[0.5em]">Next</span>
                        <span id="next-exercise-name" class="text-lg font-bold text-white/60 uppercase tracking-widest text-center">---</span>
                    </div>
                </div>

                <div class="media-controls w-full px-12 flex items-center justify-center gap-6 mt-2">
                    <button id="btn-reset" class="ios-button h-16 w-16 bg-white/5 text-white/70 rounded-full flex items-center justify-center border border-white/15 backdrop-blur-md font-semibold text-[10px] uppercase tracking-wider transition-all">
                        Reset
                    </button>
                    <div class="relative h-20 w-20">
                        <button id="btn-start" class="ios-button absolute inset-0 bg-white text-black rounded-full flex items-center justify-center shadow-2xl font-bold text-sm uppercase tracking-wide">
                            Start
                        </button>
                        <button id="btn-pause" class="ios-button hidden absolute inset-0 bg-white text-black rounded-full flex items-center justify-center shadow-2xl font-bold text-xs uppercase tracking-wide">
                            Pause
                        </button>
                    </div>
                    <button id="btn-skip" onclick="nextPhase()" class="ios-button h-16 w-16 bg-white/5 text-white/70 rounded-full flex items-center justify-center border border-white/15 backdrop-blur-md font-semibold text-[10px] uppercase tracking-wider transition-all">
                        Skip
                    </button>
                </div>
            </div>

            <div id="view-settings" class="tab-view px-4 md:px-8 pb-10">
                <div class="space-y-4 pt-4">
                    <!-- Audio Settings - FIRST -->
                    <div class="apple-glass rounded-[24px] p-5 space-y-3">
                        <label class="text-[10px] font-black text-white/40 uppercase tracking-widest mb-1 block">Audio</label>
                        
                        <div class="relative flex bg-white/[0.06] border border-white/[0.08] rounded-2xl p-1">
                            <button 
                                id="btn-audio-voice"
                                onclick="setAudioType('voice')"
                                class="tab-btn tab-active">
                                Voice
                            </button>
                            <button 
                                id="btn-audio-beep"
                                onclick="setAudioType('beep')"
                                class="tab-btn">
                                Beep
                            </button>
                            <div id="audio-indicator" class="tab-indicator"></div>
                        </div>
                    </div>
                    
                    <!-- Exercise List - SECOND -->
                    <div class="apple-glass rounded-[24px] p-5 space-y-3">
                        <div class="flex justify-between items-end">
                            <label class="text-[10px] font-black text-white/40 uppercase tracking-widest">Exercise List</label>
                            <span class="text-[9px] text-white/30 uppercase tracking-wider">Duration (Optional)</span>
                        </div>
                        
                        <input type="hidden" id="input-exercises" value="Jumping jacks, Push ups:30, Crunches, Walk outs, Squats, Mountain climbers">
                        
                        <div id="exercises-list" class="space-y-2"></div>
                        
                        <button onclick="addNewExerciseRow()" class="add-exercise-btn ios-button w-full py-3 rounded-xl bg-white/5 border border-white/10 text-xs font-bold uppercase tracking-wider text-white/60 transition-all flex items-center justify-center gap-2">
                            <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-width="3" d="M12 4v16m8-8H4"/></svg>
                            Add Exercise
                        </button>
                    </div>
                    
                    <!-- Intervals - THIRD (Reordered: Circuits, Prep, Exercise, Rest) -->
                    <div class="apple-glass rounded-[24px] p-5 space-y-3">
                        <label class="text-[10px] font-black text-white/40 uppercase tracking-widest mb-1 block">Intervals</label>
                        
                        <!-- Circuits - FIRST -->
                        <div class="grid grid-cols-[1fr_auto] gap-4 items-center py-1">
                            <span class="text-sm font-semibold text-white/70">Circuits</span>
                            <div class="flex items-center gap-2">
                                <span class="text-xl font-black tabular-nums text-white min-w-[3ch] text-right">
                                    <input 
                                        type="number" 
                                        id="input-rounds" 
                                        value="3" 
                                        min="1" 
                                        max="99"
                                        onclick="this.select()"
                                        class="w-12 bg-transparent text-xl font-black text-center outline-none tabular-nums">
                                </span>
                                <button 
                                    class="spinner-btn ios-button w-9 h-9 rounded-lg bg-white/5 border border-white/10 flex items-center justify-center text-white/60 transition-all"
                                    ontouchstart="startDecrement('input-rounds'); event.preventDefault();"
                                    ontouchend="stopAdjustment()"
                                    onmousedown="if(!('ontouchstart' in window)) startDecrement('input-rounds')"
                                    onmouseup="stopAdjustment()"
                                    onmouseleave="stopAdjustment()">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="3" viewBox="0 0 24 24"><path stroke-linecap="round" d="M20 12H4"/></svg>
                                </button>
                                <button 
                                    class="spinner-btn ios-button w-9 h-9 rounded-lg bg-white/5 border border-white/10 flex items-center justify-center text-white/60 transition-all"
                                    ontouchstart="startIncrement('input-rounds'); event.preventDefault();"
                                    ontouchend="stopAdjustment()"
                                    onmousedown="if(!('ontouchstart' in window)) startIncrement('input-rounds')"
                                    onmouseup="stopAdjustment()"
                                    onmouseleave="stopAdjustment()">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="3" viewBox="0 0 24 24"><path stroke-linecap="round" d="M12 4v16m8-8H4"/></svg>
                                </button>
                            </div>
                        </div>
                        
                        <!-- Divider -->
                        <div class="border-t border-white/10 my-2"></div>
                        
                        <!-- Prep -->
                        <div class="grid grid-cols-[1fr_auto] gap-4 items-center py-1">
                            <span class="text-sm font-semibold text-white/70">Prep</span>
                            <div class="flex items-center gap-2">
                                <input 
                                    type="text" 
                                    id="input-prepare" 
                                    value="00:10" 
                                    data-seconds="10"
                                    onclick="this.select()"
                                    onblur="handleTimeBlur('input-prepare')"
                                    class="w-16 bg-transparent text-xl font-black text-right outline-none tabular-nums">
                                <button 
                                    class="spinner-btn ios-button w-9 h-9 rounded-lg bg-white/5 border border-white/10 flex items-center justify-center text-white/60 transition-all"
                                    ontouchstart="startTimeDecrement('input-prepare', event); event.preventDefault();"
                                    ontouchend="stopAdjustment()"
                                    onmousedown="if(!('ontouchstart' in window)) startTimeDecrement('input-prepare', event)"
                                    onmouseup="stopAdjustment()"
                                    onmouseleave="stopAdjustment()">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="3" viewBox="0 0 24 24"><path stroke-linecap="round" d="M20 12H4"/></svg>
                                </button>
                                <button 
                                    class="spinner-btn ios-button w-9 h-9 rounded-lg bg-white/5 border border-white/10 flex items-center justify-center text-white/60 transition-all"
                                    ontouchstart="startTimeIncrement('input-prepare', event); event.preventDefault();"
                                    ontouchend="stopAdjustment()"
                                    onmousedown="if(!('ontouchstart' in window)) startTimeIncrement('input-prepare', event)"
                                    onmouseup="stopAdjustment()"
                                    onmouseleave="stopAdjustment()">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="3" viewBox="0 0 24 24"><path stroke-linecap="round" d="M12 4v16m8-8H4"/></svg>
                                </button>
                            </div>
                        </div>
                        
                        <!-- Exercise (was Work) -->
                        <div class="grid grid-cols-[1fr_auto] gap-4 items-center py-1">
                            <span class="text-sm font-semibold text-white/70">Exercise</span>
                            <div class="flex items-center gap-2">
                                <input 
                                    type="text" 
                                    id="input-work" 
                                    value="00:45" 
                                    data-seconds="45"
                                    onclick="this.select()"
                                    onblur="handleTimeBlur('input-work')"
                                    class="w-16 bg-transparent text-xl font-black text-right outline-none tabular-nums">
                                <button 
                                    class="spinner-btn ios-button w-9 h-9 rounded-lg bg-white/5 border border-white/10 flex items-center justify-center text-white/60 transition-all"
                                    ontouchstart="startTimeDecrement('input-work', event); event.preventDefault();"
                                    ontouchend="stopAdjustment()"
                                    onmousedown="if(!('ontouchstart' in window)) startTimeDecrement('input-work', event)"
                                    onmouseup="stopAdjustment()"
                                    onmouseleave="stopAdjustment()">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="3" viewBox="0 0 24 24"><path stroke-linecap="round" d="M20 12H4"/></svg>
                                </button>
                                <button 
                                    class="spinner-btn ios-button w-9 h-9 rounded-lg bg-white/5 border border-white/10 flex items-center justify-center text-white/60 transition-all"
                                    ontouchstart="startTimeIncrement('input-work', event); event.preventDefault();"
                                    ontouchend="stopAdjustment()"
                                    onmousedown="if(!('ontouchstart' in window)) startTimeIncrement('input-work', event)"
                                    onmouseup="stopAdjustment()"
                                    onmouseleave="stopAdjustment()">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="3" viewBox="0 0 24 24"><path stroke-linecap="round" d="M12 4v16m8-8H4"/></svg>
                                </button>
                            </div>
                        </div>
                        
                        <!-- Rest -->
                        <div class="grid grid-cols-[1fr_auto] gap-4 items-center py-1">
                            <span class="text-sm font-semibold text-white/70">Rest</span>
                            <div class="flex items-center gap-2">
                                <input 
                                    type="text" 
                                    id="input-rest" 
                                    value="00:15" 
                                    data-seconds="15"
                                    onclick="this.select()"
                                    onblur="handleTimeBlur('input-rest')"
                                    class="w-16 bg-transparent text-xl font-black text-right outline-none tabular-nums">
                                <button 
                                    class="spinner-btn ios-button w-9 h-9 rounded-lg bg-white/5 border border-white/10 flex items-center justify-center text-white/60 transition-all"
                                    ontouchstart="startTimeDecrement('input-rest', event); event.preventDefault();"
                                    ontouchend="stopAdjustment()"
                                    onmousedown="if(!('ontouchstart' in window)) startTimeDecrement('input-rest', event)"
                                    onmouseup="stopAdjustment()"
                                    onmouseleave="stopAdjustment()">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="3" viewBox="0 0 24 24"><path stroke-linecap="round" d="M20 12H4"/></svg>
                                </button>
                                <button 
                                    class="spinner-btn ios-button w-9 h-9 rounded-lg bg-white/5 border border-white/10 flex items-center justify-center text-white/60 transition-all"
                                    ontouchstart="startTimeIncrement('input-rest', event); event.preventDefault();"
                                    ontouchend="stopAdjustment()"
                                    onmousedown="if(!('ontouchstart' in window)) startTimeIncrement('input-rest', event)"
                                    onmouseup="stopAdjustment()"
                                    onmouseleave="stopAdjustment()">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="3" viewBox="0 0 24 24"><path stroke-linecap="round" d="M12 4v16m8-8H4"/></svg>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
                </div>
            </div>
        </div>

        <div id="message-box" class="fixed top-8 left-1/2 -translate-x-1/2 px-8 py-3 rounded-full apple-glass text-white font-black text-[10px] shadow-2xl transition-all opacity-0 pointer-events-none z-50 uppercase tracking-widest">Workout Complete</div>
    </div>

    <script>
        // ============================================
        // WAKE LOCK MANAGER
        // ============================================
        class WakeLockManager {
            constructor() {
                this.wakeLock = null;
                this.isSupported = 'wakeLock' in navigator;
            }

            async enable() {
                if (!this.isSupported) {
                    console.warn('Wake Lock API is not supported in this browser');
                    return;
                }

                try {
                    this.wakeLock = await navigator.wakeLock.request('screen');
                    console.log('âœ“ Wake Lock enabled - screen will stay on');
                    
                    this.wakeLock.addEventListener('release', () => {
                        console.log('Wake Lock was released');
                    });
                } catch (err) {
                    console.error('Failed to enable Wake Lock:', err);
                }
            }

            async disable() {
                if (this.wakeLock) {
                    try {
                        await this.wakeLock.release();
                        this.wakeLock = null;
                        console.log('âœ“ Wake Lock disabled');
                    } catch (err) {
                        console.error('Error releasing Wake Lock:', err);
                    }
                }
            }

            async reEnable() {
                if (this.wakeLock !== null || this.isSupported) {
                    await this.disable();
                    await this.enable();
                }
            }
        }

        const wakeLockManager = new WakeLockManager();

        document.addEventListener('visibilitychange', async () => {
            if (document.visibilityState === 'hidden') {
                // Auto-pause when backgrounded to prevent battery drain and stop workout
                if (timer && !isPaused) {
                    togglePause();
                }
            }
        });

        // ============================================
        // SPEECH SYNTHESIS MANAGER (iOS-Compatible)
        // ============================================
        class SpeechManager {
            constructor() {
                this.isInitialized = false;
                this.isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            }

            initialize() {
                if (this.isInitialized) return;
                
                if (this.isIOS && 'speechSynthesis' in window) {
                    const utterance = new SpeechSynthesisUtterance('');
                    utterance.volume = 0;
                    window.speechSynthesis.speak(utterance);
                    this.isInitialized = true;
                    console.log('âœ“ Speech synthesis initialized for iOS');
                } else {
                    this.isInitialized = true;
                }
            }

            speak(text, voiceEnabled) {
                if (!voiceEnabled) return;
                
                if (!this.isInitialized) {
                    this.initialize();
                }

                window.speechSynthesis.cancel();

                setTimeout(() => {
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.rate = 1.1;
                    utterance.volume = 1.0;
                    utterance.lang = 'en-US';
                    
                    if (this.isIOS) {
                        utterance.rate = 1.0;
                    }
                    
                    window.speechSynthesis.speak(utterance);
                    console.log('ðŸ”Š Speaking:', text);
                }, this.isIOS ? 100 : 0);
            }

            cancel() {
                window.speechSynthesis.cancel();
            }
        }

        const speechManager = new SpeechManager();

        // ============================================
        // TIMER CODE
        // ============================================
        const CIRCLE_RADIUS = 148;
        const CIRCUMFERENCE = 2 * Math.PI * CIRCLE_RADIUS;
        let timer = null, isPaused = false, currentPhase = 'prepare', globalIntervalIndex = 0, secondsRemaining = 0, totalPhaseSeconds = 0, totalTimeRemaining = 0, exerciseObjects = [], phaseEndTime = 0, pausedTimeRemainingMs = 0;
        
        // Frame throttling settings (30 FPS)
        const TARGET_FPS = 30;
        const FRAME_INTERVAL = 1000 / TARGET_FPS;
        let lastFrameTime = 0;

        const timeLeftEl = document.getElementById('time-left');
        const roundDisplayEl = document.getElementById('round-display');
        const circuitDisplayEl = document.getElementById('circuit-display');
        const totalTimeDisplayEl = document.getElementById('total-time-display');
        const exerciseTextEl = document.getElementById('current-exercise');
        const progressCircle = document.getElementById('progress-circle');
        const navIndicator = document.getElementById('nav-indicator');
        const btnMute = document.getElementById('btn-mute');
        const iconMuted = document.getElementById('icon-muted');
        const iconUnmuted = document.getElementById('icon-unmuted');
        const btnStart = document.getElementById('btn-start');
        const btnPause = document.getElementById('btn-pause');
        const nextUpContainer = document.getElementById('next-up-container');
        const nextExerciseNameEl = document.getElementById('next-exercise-name');
        const inputWork = document.getElementById('input-work'), inputRest = document.getElementById('input-rest'), inputRounds = document.getElementById('input-rounds'), inputPrepare = document.getElementById('input-prepare');
        
        // Native Data Model (Source of Truth)
        let exercisesData = [
            { name: "Jumping jacks", duration: null },
            { name: "Push ups", duration: 30 },
            { name: "Crunches", duration: null },
            { name: "Walk outs", duration: null },
            { name: "Squats", duration: null },
            { name: "Mountain climbers", duration: null }
        ];
        
        // Voice state variable (controlled by mute button)
        let voiceEnabled = true;
        let audioType = 'voice'; // 'voice' or 'beep'
        
        // Beep sound generator
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        function playBeep(frequency = 800, duration = 100) {
            if (!voiceEnabled) return;
            
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = frequency;
                oscillator.type = 'sine';
                
                const now = audioContext.currentTime;
                gainNode.gain.setValueAtTime(0.3, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + duration / 1000);
                
                oscillator.start(now);
                oscillator.stop(now + duration / 1000);
            } catch (e) {
                console.error('Beep error:', e);
            }
        }

        function saveSettings() {
            const settings = {
                exercises: exercisesData,
                workTime: getSecondsFromTimeInput('input-work'),
                restTime: getSecondsFromTimeInput('input-rest'),
                circuits: inputRounds.value,
                prepTime: getSecondsFromTimeInput('input-prepare'),
                voiceEnabled: voiceEnabled,
                audioType: audioType
            };
            localStorage.setItem('intervalTimerSettings', JSON.stringify(settings));
        }

        function loadSettings() {
            const saved = localStorage.getItem('intervalTimerSettings');
            if (saved) {
                try {
                    const settings = JSON.parse(saved);
                    
                    // Handle legacy string format or new array format
                    if (settings.exercises) {
                        if (typeof settings.exercises === 'string') {
                            exercisesData = settings.exercises.split(',').filter(i => i.trim() !== "").map(item => {
                                const parts = item.split(':');
                                return { name: parts[0].trim(), duration: (parts[1] && !isNaN(parseInt(parts[1].trim()))) ? parseInt(parts[1].trim()) : null };
                            });
                        } else if (Array.isArray(settings.exercises)) {
                            exercisesData = settings.exercises;
                        }
                    }
                    
                    // Load time values
                    if (settings.workTime !== undefined) {
                        setTimeInputSeconds('input-work', settings.workTime);
                    }
                    if (settings.restTime !== undefined) {
                        setTimeInputSeconds('input-rest', settings.restTime);
                    }
                    if (settings.prepTime !== undefined) {
                        setTimeInputSeconds('input-prepare', settings.prepTime);
                    }
                    
                    inputRounds.value = settings.circuits || inputRounds.value;
                    voiceEnabled = settings.voiceEnabled !== undefined ? settings.voiceEnabled : true;
                    handleMuteToggle(voiceEnabled);
                    
                    // Load audio type
                    audioType = settings.audioType || 'voice';
                    updateAudioTypeUI();
                    renderExerciseList();
                } catch (e) {
                    console.error('Error loading settings:', e);
                }
            }
        }
        
        function setAudioType(type) {
            audioType = type;
            updateAudioTypeUI();
            saveSettings();
        }
        
        function updateAudioTypeUI() {
            const voiceBtn = document.getElementById('btn-audio-voice');
            const beepBtn = document.getElementById('btn-audio-beep');
            const indicator = document.getElementById('audio-indicator');
            
            if (!voiceBtn || !beepBtn || !indicator) return;
            
            if (audioType === 'voice') {
                voiceBtn.classList.add('tab-active');
                beepBtn.classList.remove('tab-active');
                indicator.style.transform = 'translateX(0%)';
            } else {
                voiceBtn.classList.remove('tab-active');
                beepBtn.classList.add('tab-active');
                indicator.style.transform = 'translateX(100%)';
            }
        }

        function setupAutoSave() {
            [inputWork, inputRest, inputRounds, inputPrepare].forEach(el => {
                el.addEventListener('input', () => {
                    saveSettings();
                    updateTotalTimeDisplay();
                    updateCountsDisplay();
                });
                
                el.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.target.blur();
                    }
                });
            });
        }

        // ============================================
        // EXERCISE LIST UI HANDLERS
        // ============================================
        function renderExerciseList() {
            const container = document.getElementById('exercises-list');
            if (!container) return;
            container.innerHTML = '';
            
            exercisesData.forEach(item => {
                createExerciseRow(item.name, item.duration || '');
            });
            
            if (exercisesData.length === 0) createExerciseRow('', '');
        }

        function createExerciseRow(name = '', duration = '') {
            const container = document.getElementById('exercises-list');
            const div = document.createElement('div');
            
            // Format duration if it exists
            const formattedDuration = (duration !== '' && duration !== null) ? formatToMMSS(duration) : '';
            
            // Add transition classes for entry animation
            div.className = 'exercise-row relative overflow-hidden rounded-xl transition-all duration-300 ease-out opacity-0 translate-y-2 max-h-0';
            div.innerHTML = `
                <div class="slide-track flex w-full h-full touch-pan-y transition-transform duration-200 ease-out">
                    <div class="row-content w-full flex-shrink-0 flex items-center bg-white/5 py-3 px-4">
                        <input type="text" value="${name}" placeholder="Exercise Name" class="exercise-name-input flex-1 min-w-0 bg-transparent border-none p-0 text-sm font-medium focus:ring-0 outline-none placeholder:text-white/20 text-white">
                        
                        <input type="text" value="${formattedDuration}" placeholder="--:--" onclick="this.select()" class="exercise-duration-input w-14 bg-transparent border-none p-0 text-sm text-right focus:ring-0 outline-none placeholder:text-white/20 text-white tabular-nums font-medium mx-3">

                        <div class="drag-handle w-6 h-6 flex-shrink-0 flex items-center justify-center text-white/30 hover:text-white transition-all cursor-grab active:cursor-grabbing touch-none">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8h16M4 16h16"/></svg>
                        </div>
                    </div>

                    <div class="delete-action w-[100px] flex-shrink-0 bg-red-500 flex items-center justify-center">
                        <button onclick="removeExerciseRow(this)" class="text-white font-bold text-xs uppercase tracking-wider h-full w-full flex items-center justify-center">Delete</button>
                    </div>
                </div>
            `;
            container.appendChild(div);
            
            // Trigger animation
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    div.classList.remove('opacity-0', 'translate-y-2', 'max-h-0');
                    div.classList.add('max-h-20');
                });
            });
            
            const slideTrack = div.querySelector('.slide-track');
            setupSlideInteraction(slideTrack);
            
            const handle = div.querySelector('.drag-handle');
            handle.addEventListener('touchstart', handleDragStart, {passive: false});
            handle.addEventListener('mousedown', handleDragStart);
            
            const inputs = div.querySelectorAll('input');
            inputs.forEach(input => {
                input.addEventListener('input', updateExercisesFromUI);
                
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.target.blur();
                    }
                });
                
                // Add blur handler for time formatting
                if (input.classList.contains('exercise-duration-input')) {
                    input.addEventListener('blur', function() {
                        const val = this.value.trim();
                        if (val) {
                            const seconds = parseTimeInput(val);
                            this.value = seconds > 0 ? formatToMMSS(seconds) : '';
                        }
                        updateExercisesFromUI();
                    });
                }
            });
        }

        function setupSlideInteraction(element) {
            let startX = 0;
            let startY = 0;
            let currentTranslate = 0;
            let isDragging = false;
            let isOpen = false;
            
            const startDrag = (clientX, clientY) => {
                startX = clientX;
                startY = clientY;
                isDragging = true;
                element.style.transition = 'none';
            };

            const moveDrag = (clientX, clientY, e) => {
                if (!isDragging) return;
                const diffX = clientX - startX;
                const diffY = clientY - startY;
                
                // Ensure it's a horizontal swipe
                if (Math.abs(diffX) > Math.abs(diffY)) {
                    // If closed, only allow sliding left (diffX < 0)
                    if (!isOpen && diffX > 0) return;

                    if (e.cancelable) e.preventDefault(); // Stop vertical scrolling
                    
                    const baseTranslate = isOpen ? -100 : 0;
                    currentTranslate = Math.max(Math.min(baseTranslate + diffX, 0), -100); 
                    element.style.transform = `translateX(${currentTranslate}px)`;
                }
            };

            const endDrag = () => {
                if (!isDragging) return;
                isDragging = false;
                element.style.transition = 'transform 0.2s ease-out';
                if (currentTranslate < -50) {
                    element.style.transform = 'translateX(-100px)'; // Keep open
                    isOpen = true;
                    currentTranslate = -100;
                } else {
                    element.style.transform = 'translateX(0)'; // Close
                    isOpen = false;
                    currentTranslate = 0;
                }
            };
            
            // Touch Events
            element.addEventListener('touchstart', e => startDrag(e.touches[0].clientX, e.touches[0].clientY), {passive: true});
            element.addEventListener('touchmove', e => moveDrag(e.touches[0].clientX, e.touches[0].clientY, e), {passive: false});
            element.addEventListener('touchend', endDrag);
            
            // Mouse Events (PC)
            element.addEventListener('mousedown', e => startDrag(e.clientX, e.clientY));
            window.addEventListener('mousemove', e => {
                if (isDragging) {
                    e.preventDefault(); // Prevent text selection
                    moveDrag(e.clientX, e.clientY, e);
                }
            });
            window.addEventListener('mouseup', endDrag);
        }

        function addNewExerciseRow() {
            createExerciseRow('', '');
            updateExercisesFromUI();
        }

        function removeExerciseRow(btn) {
            const row = btn.closest('.exercise-row');
            
            // Set explicit height for transition
            row.style.maxHeight = row.scrollHeight + 'px';
            row.classList.add('overflow-hidden');
            void row.offsetWidth; // Force reflow

            // Exit animation
            row.style.maxHeight = '0px';
            row.classList.add('opacity-0', '-translate-y-2', '!mt-0', '!mb-0', 'pointer-events-none');
            
            setTimeout(() => {
                row.remove();
                updateExercisesFromUI();
                
                // Ensure we don't leave an empty list
                if (document.getElementById('exercises-list').children.length === 0) {
                    addNewExerciseRow();
                }
            }, 300);
        }

        // ============================================
        // DRAG AND DROP REORDERING
        // ============================================
        let draggingRow = null;
        let ghost = null;
        let dragOffsetY = 0;

        function handleDragStart(e) {
            const handle = e.target.closest('.drag-handle');
            if (!handle) return;
            
            // Prevent text selection on desktop
            if (e.type === 'mousedown') e.preventDefault();
            
            const row = handle.closest('.exercise-row');
            if (!row) return;
            
            draggingRow = row;
            
            // Calculate offset to keep ghost under finger relative to row top
            const rect = row.getBoundingClientRect();
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            dragOffsetY = clientY - rect.top;
            
            // Create Ghost
            ghost = row.cloneNode(true);
            ghost.classList.add('ghost');
            ghost.style.width = rect.width + 'px';
            ghost.style.height = rect.height + 'px';
            ghost.style.top = rect.top + 'px';
            ghost.style.left = rect.left + 'px';
            // Reset any slide transforms on the ghost
            const ghostTrack = ghost.querySelector('.slide-track');
            if (ghostTrack) ghostTrack.style.transform = 'none';
            document.body.appendChild(ghost);
            
            row.classList.add('placeholder');
            
            // Prevent scrolling on touch
            if (e.type === 'touchstart') {
                document.body.style.overflow = 'hidden';
                document.addEventListener('touchmove', onDragMove, {passive: false});
                document.addEventListener('touchend', onDragEnd);
            } else {
                document.addEventListener('mousemove', onDragMove);
                document.addEventListener('mouseup', onDragEnd);
            }
        }

        function onDragMove(e) {
            if (!draggingRow || !ghost) return;
            if (e.type === 'touchmove') e.preventDefault();
            
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            
            // Move Ghost
            ghost.style.top = (clientY - dragOffsetY) + 'px';
            
            const elementBelow = document.elementFromPoint(clientX, clientY);
            if (!elementBelow) return;
            
            const rowBelow = elementBelow.closest('.exercise-row');
            
            if (rowBelow && rowBelow !== draggingRow) {
                const container = document.getElementById('exercises-list');
                const rows = Array.from(container.children);
                
                const draggingIndex = rows.indexOf(draggingRow);
                const targetIndex = rows.indexOf(rowBelow);
                
                // Calculate threshold to prevent flickering
                const targetRect = rowBelow.getBoundingClientRect();
                const targetMiddleY = targetRect.top + targetRect.height / 2;
                const isMovingDown = draggingIndex < targetIndex;
                
                // Only swap if we have crossed the midline of the target element
                if (isMovingDown && clientY < targetMiddleY) return;
                if (!isMovingDown && clientY > targetMiddleY) return;

                // FLIP Animation: Capture old positions
                const positions = new Map();
                rows.forEach(r => positions.set(r, r.getBoundingClientRect().top));

                if (isMovingDown) {
                    container.insertBefore(draggingRow, rowBelow.nextSibling);
                } else {
                    container.insertBefore(draggingRow, rowBelow);
                }
                
                // FLIP Animation: Play
                rows.forEach(r => {
                    if (r === draggingRow) return; // Don't animate placeholder
                    const oldTop = positions.get(r);
                    const newTop = r.getBoundingClientRect().top;
                    
                    if (oldTop && newTop && oldTop !== newTop) {
                        const delta = oldTop - newTop;
                        r.style.transition = 'none';
                        r.style.transform = `translateY(${delta}px)`;
                        
                        requestAnimationFrame(() => {
                            r.style.transition = 'transform 0.3s ease';
                            r.style.transform = '';
                        });
                    }
                });
            }
        }

        function onDragEnd(e) {
            if (draggingRow && ghost) {
                // Animate ghost to final position
                const rect = draggingRow.getBoundingClientRect();
                ghost.style.transition = 'top 0.2s ease, left 0.2s ease';
                ghost.style.top = rect.top + 'px';
                ghost.style.left = rect.left + 'px';
                
                setTimeout(() => {
                    if (ghost) ghost.remove();
                    if (draggingRow) draggingRow.classList.remove('placeholder');
                    ghost = null;
                    draggingRow = null;
                    updateExercisesFromUI();
                }, 200);
            } else {
                draggingRow = null;
            }
            
            document.body.style.overflow = '';
            
            document.removeEventListener('touchmove', onDragMove);
            document.removeEventListener('touchend', onDragEnd);
            document.removeEventListener('mousemove', onDragMove);
            document.removeEventListener('mouseup', onDragEnd);
        }

        function updateExercisesFromUI() {
            const container = document.getElementById('exercises-list');
            const rows = container.querySelectorAll('.exercise-row');
            const newExercises = [];
            
            rows.forEach(row => {
                const nameInput = row.querySelector('.exercise-name-input');
                const durInput = row.querySelector('.exercise-duration-input');
                let name = nameInput.value.trim();
                let durationVal = durInput.value.trim();
                
                if (name) {
                    newExercises.push({ name: name, duration: durationVal ? parseTimeInput(durationVal) : null });
                }
            });
            
            exercisesData = newExercises;
            
            saveSettings();
            updateTotalTimeDisplay();
            updateCountsDisplay();
        }

        // ============================================
        // TIME INPUT HELPERS (MM:SS format)
        // ============================================
        function parseTimeInput(value) {
            // Remove any spaces
            value = value.trim();
            
            // If contains colon, parse as MM:SS
            if (value.includes(':')) {
                const parts = value.split(':');
                const min = parseInt(parts[0]) || 0;
                const sec = parseInt(parts[1]) || 0;
                return min * 60 + sec;
            }
            
            // Otherwise treat as seconds
            return parseInt(value) || 0;
        }

        function formatToMMSS(seconds) {
            seconds = Math.max(0, seconds); // No negatives
            const min = Math.floor(seconds / 60);
            const sec = seconds % 60;
            return `${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;
        }

        function handleTimeBlur(inputId) {
            const input = document.getElementById(inputId);
            const seconds = parseTimeInput(input.value);
            input.setAttribute('data-seconds', seconds);
            input.value = formatToMMSS(seconds);
            
            // Trigger save and update
            saveSettings();
            updateTotalTimeDisplay();
        }

        function getSecondsFromTimeInput(inputId) {
            const input = document.getElementById(inputId);
            return parseInt(input.getAttribute('data-seconds')) || 0;
        }

        function setTimeInputSeconds(inputId, seconds) {
            const input = document.getElementById(inputId);
            seconds = Math.max(0, seconds);
            input.setAttribute('data-seconds', seconds);
            input.value = formatToMMSS(seconds);
            
            // Trigger save and update
            input.dispatchEvent(new Event('input'));
        }

        // ============================================
        // INCREMENT/DECREMENT WITH LONG-PRESS (for time inputs)
        // ============================================
        let adjustmentInterval = null;
        let adjustmentTimeout = null;
        let speedUpTimeout = null;
        let isAdjusting = false; // Prevent double-fire on mobile

        function incrementTimeValue(inputId) {
            const seconds = getSecondsFromTimeInput(inputId);
            setTimeInputSeconds(inputId, seconds + 5); // +5 seconds
            
            // Haptic feedback on mobile
            if (navigator.vibrate) {
                navigator.vibrate(10);
            }
        }

        function decrementTimeValue(inputId) {
            const seconds = getSecondsFromTimeInput(inputId);
            setTimeInputSeconds(inputId, seconds - 5); // -5 seconds
            
            // Haptic feedback on mobile
            if (navigator.vibrate) {
                navigator.vibrate(10);
            }
        }

        function startTimeIncrement(inputId, event) {
            if (isAdjusting) return;
            if (event) event.preventDefault();
            isAdjusting = true;
            
            incrementTimeValue(inputId);
            
            adjustmentTimeout = setTimeout(() => {
                adjustmentInterval = setInterval(() => {
                    incrementTimeValue(inputId);
                }, 150);
                
                speedUpTimeout = setTimeout(() => {
                    clearInterval(adjustmentInterval);
                    adjustmentInterval = setInterval(() => {
                        incrementTimeValue(inputId);
                    }, 75);
                }, 2000);
            }, 500);
        }

        function startTimeDecrement(inputId, event) {
            if (isAdjusting) return;
            if (event) event.preventDefault();
            isAdjusting = true;
            
            decrementTimeValue(inputId);
            
            adjustmentTimeout = setTimeout(() => {
                adjustmentInterval = setInterval(() => {
                    decrementTimeValue(inputId);
                }, 150);
                
                speedUpTimeout = setTimeout(() => {
                    clearInterval(adjustmentInterval);
                    adjustmentInterval = setInterval(() => {
                        decrementTimeValue(inputId);
                    }, 75);
                }, 2000);
            }, 500);
        }

        function stopAdjustment() {
            clearTimeout(adjustmentTimeout);
            clearTimeout(speedUpTimeout);
            clearInterval(adjustmentInterval);
            adjustmentTimeout = null;
            speedUpTimeout = null;
            adjustmentInterval = null;
            isAdjusting = false;
        }

        // ============================================
        // CIRCUITS INCREMENT/DECREMENT (still uses +/- 1)
        // ============================================
        function incrementValue(inputId) {
            const input = document.getElementById(inputId);
            const currentValue = parseInt(input.value) || 0;
            const min = parseInt(input.min) || 0;
            const max = parseInt(input.max) || 999;
            
            if (currentValue < max) {
                input.value = currentValue + 1;
                input.dispatchEvent(new Event('input'));
                
                if (navigator.vibrate) {
                    navigator.vibrate(10);
                }
            }
        }

        function decrementValue(inputId) {
            const input = document.getElementById(inputId);
            const currentValue = parseInt(input.value) || 0;
            const min = parseInt(input.min) || 0;
            
            if (currentValue > min) {
                input.value = currentValue - 1;
                input.dispatchEvent(new Event('input'));
                
                if (navigator.vibrate) {
                    navigator.vibrate(10);
                }
            }
        }

        function startIncrement(inputId) {
            incrementValue(inputId);
            
            adjustmentTimeout = setTimeout(() => {
                adjustmentInterval = setInterval(() => {
                    incrementValue(inputId);
                }, 150);
                
                speedUpTimeout = setTimeout(() => {
                    clearInterval(adjustmentInterval);
                    adjustmentInterval = setInterval(() => {
                        incrementValue(inputId);
                    }, 75);
                }, 2000);
            }, 500);
        }

        function startDecrement(inputId) {
            decrementValue(inputId);
            
            adjustmentTimeout = setTimeout(() => {
                adjustmentInterval = setInterval(() => {
                    decrementValue(inputId);
                }, 150);
                
                speedUpTimeout = setTimeout(() => {
                    clearInterval(adjustmentInterval);
                    adjustmentInterval = setInterval(() => {
                        decrementValue(inputId);
                    }, 75);
                }, 2000);
            }, 500);
        }


        function switchTab(tab) {
            const timerView = document.getElementById('view-timer');
            const settingsView = document.getElementById('view-settings');
            const tabTimerBtn = document.getElementById('tab-timer');
            const tabSettingsBtn = document.getElementById('tab-settings');

            if (tab === 'timer') {
                settingsView.classList.remove('active');
                timerView.classList.add('active');
                tabTimerBtn.classList.add('tab-active');
                tabSettingsBtn.classList.remove('tab-active');
                navIndicator.style.transform = 'translateX(0%)';
                updateTotalTimeDisplay();
            } else {
                timerView.classList.remove('active');
                settingsView.classList.add('active');
                tabSettingsBtn.classList.add('tab-active');
                tabTimerBtn.classList.remove('tab-active');
                navIndicator.style.transform = 'translateX(100%)';
                if (timer && !isPaused) togglePause();
            }
        }

        function toggleMute() { 
            voiceEnabled = !voiceEnabled; 
            handleMuteToggle(voiceEnabled);
            saveSettings();
        }
        
        function handleMuteToggle(isUnmuted) {
            if (isUnmuted) { 
                btnMute.classList.remove('is-muted'); 
                iconMuted.classList.add('hidden'); 
                iconUnmuted.classList.remove('hidden'); 
            } else { 
                btnMute.classList.add('is-muted'); 
                iconMuted.classList.remove('hidden'); 
                iconUnmuted.classList.add('hidden'); 
                speechManager.cancel();
            }
        }
        
        function speak(text) {
            if (!voiceEnabled) return;
            
            console.log('speak() called with:', text, 'audioType:', audioType); // Debug
            
            if (audioType === 'beep') {
                // Different beep patterns for different announcements
                if (text.match(/^\d+$/)) {
                    // Countdown numbers: short high beep
                    console.log('Countdown beep');
                    playBeep(1200, 80);
                } else if (text.includes('Rest')) {
                    // Rest period: low beep
                    console.log('Rest beep');
                    playBeep(400, 150);
                } else if (text.includes('Begin') || text.includes('Start')) {
                    // Exercise start: double beep
                    console.log('Begin beep');
                    playBeep(800, 150);
                    setTimeout(() => playBeep(800, 150), 200);
                } else if (text.toLowerCase().includes('complete') || text.toLowerCase().includes('amazing')) {
                    // Workout complete: FAST energetic victory beeps! ðŸŽ‰
                    console.log('VICTORY BEEPS! Text was:', text);
                    playBeep(700, 120);  // Quick ascending melody
                    setTimeout(() => {
                        console.log('Second beep playing');
                        playBeep(900, 120);
                    }, 150);
                    setTimeout(() => {
                        console.log('Third beep playing');
                        playBeep(1100, 180); // Longer final note
                    }, 300);
                } else {
                    // Default: single beep
                    console.log('Default beep for:', text);
                    playBeep(800, 120);
                }
            } else {
                // Use voice
                speechManager.speak(text, voiceEnabled);
            }
        }
        
        function updateProgress(percent) { 
            // Direct update for smooth animation via requestAnimationFrame
            progressCircle.style.strokeDashoffset = CIRCUMFERENCE - (percent / 100 * CIRCUMFERENCE);
        }
        function formatTime(seconds) { return `${Math.floor(seconds / 60).toString().padStart(2, '0')}:${(seconds % 60).toString().padStart(2, '0')}`; }
        function parseExercises() { 
            const defaultWork = getSecondsFromTimeInput('input-work'); 
            return exercisesData.map(item => { 
                return { 
                    name: item.name, 
                    duration: item.duration || defaultWork 
                }; 
            }); 
        }
        
        function calculateTotalTime() {
            const exercises = parseExercises();
            if (exercises.length === 0) return 0;
            
            const circuits = parseInt(inputRounds.value);
            const restTime = getSecondsFromTimeInput('input-rest');
            const prepTime = getSecondsFromTimeInput('input-prepare');
            
            let totalWorkTime = 0;
            exercises.forEach(ex => {
                totalWorkTime += ex.duration;
            });
            
            const totalTime = prepTime + (totalWorkTime * circuits) + (restTime * (exercises.length * circuits - 1));
            
            return totalTime;
        }
        
        function updateTotalTimeDisplay(secondsOverride = null) {
            // If a specific time is provided (during workout), use it. 
            // Otherwise calculate from settings (during setup).
            const totalSeconds = secondsOverride !== null ? secondsOverride : calculateTotalTime();
            
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            totalTimeDisplayEl.innerText = `Total: ${minutes}:${seconds.toString().padStart(2, '0')}`;
        }
        
        function updateCountsDisplay() {
            const exercises = parseExercises();
            const totalCircuits = parseInt(inputRounds.value) || 1;
            const count = exercises.length || 0;
            
            // Always show the counts based on current settings
            roundDisplayEl.innerText = count > 0 ? `Exercise 1 / ${count}` : 'Ready';
            circuitDisplayEl.innerText = count > 0 ? `Circuit 1 / ${totalCircuits}` : ' ';
            
            // Show first exercise as "Next" when stopped
            if (!timer && !isPaused) {
                if (count > 0) {
                    nextExerciseNameEl.innerText = exercises[0].name;
                    nextUpContainer.classList.remove('opacity-0');
                    nextUpContainer.classList.add('opacity-100');
                } else {
                    nextUpContainer.classList.remove('opacity-100');
                    nextUpContainer.classList.add('opacity-0');
                }
            }
        }
        
        function getIntervalData(index) { 
            const listSize = exerciseObjects.length; 
            if (listSize === 0) return null; 
            return { 
                exercise: exerciseObjects[index % listSize], 
                exerciseNum: (index % listSize) + 1, 
                circuitNum: Math.floor(index / listSize) + 1, 
                isLastOverall: (index === (listSize * parseInt(inputRounds.value)) - 1) 
            }; 
        }

        function setVisualState(phase) {
            const colors = { prepare: 'text-blue-500', work: 'text-emerald-500', rest: 'text-orange-500' };
            const textColors = { prepare: 'text-blue-400', work: 'text-emerald-400', rest: 'text-orange-400' };
            
            progressCircle.classList.remove('text-blue-500', 'text-emerald-500', 'text-orange-500', 'text-yellow-300', 'text-yellow-400');
            progressCircle.classList.add(colors[phase]);
            
            exerciseTextEl.classList.remove('text-blue-400', 'text-emerald-400', 'text-orange-400', 'text-yellow-300', 'text-yellow-400');
            exerciseTextEl.classList.add(textColors[phase]);
            
            
            if (phase === 'prepare') {
                exerciseTextEl.innerText = "Get Ready";
                const info = getIntervalData(0);
                roundDisplayEl.innerText = `Exercise ${info.exerciseNum} / ${exerciseObjects.length}`;
                circuitDisplayEl.innerText = `Circuit ${info.circuitNum} / ${inputRounds.value}`;
                nextExerciseNameEl.innerText = info.exercise.name;
                nextUpContainer.classList.replace('opacity-0', 'opacity-100');
                speak(`Get ready. First, ${info.exercise.name}.`);
            } else if (phase === 'rest') {
                exerciseTextEl.innerText = "Rest";
                const info = getIntervalData(globalIntervalIndex + 1);
                nextExerciseNameEl.innerText = info.exercise.name;
                nextUpContainer.classList.replace('opacity-0', 'opacity-100');
                speak(`Rest. Next is ${info.exercise.name}.`);
            } else {
                const info = getIntervalData(globalIntervalIndex);
                exerciseTextEl.innerText = info.exercise.name;
                roundDisplayEl.innerText = `Exercise ${info.exerciseNum} / ${exerciseObjects.length}`;
                circuitDisplayEl.innerText = `Circuit ${info.circuitNum} / ${inputRounds.value}`;
                
                if (!info.isLastOverall) {
                    nextExerciseNameEl.innerText = "Rest";
                    nextUpContainer.classList.replace('opacity-0', 'opacity-100');
                } else {
                    nextUpContainer.classList.replace('opacity-100', 'opacity-0');
                }
                speak(info.exercise.name + ". Begin.");
                //speak(info.exercise.name + ". Start.");
            }
        }

        function runTimerLoop() {
            if (isPaused) return;
            
            // Schedule next frame immediately
            timer = requestAnimationFrame(runTimerLoop);
            
            const now = Date.now();
            const elapsed = now - lastFrameTime;
            
            // Throttle to TARGET_FPS
            if (elapsed < FRAME_INTERVAL) return;
            
            lastFrameTime = now - (elapsed % FRAME_INTERVAL);
            
            const timeLeftMs = phaseEndTime - now;
            
            if (timeLeftMs <= 0) {
                cancelAnimationFrame(timer);
                nextPhase();
                return;
            }

            // Smooth progress update
            const percent = (timeLeftMs / (totalPhaseSeconds * 1000)) * 100;
            updateProgress(percent);

            // Integer second updates
            const currentSeconds = Math.ceil(timeLeftMs / 1000);
            if (currentSeconds !== secondsRemaining) {
                secondsRemaining = currentSeconds;
                timeLeftEl.innerText = formatTime(secondsRemaining);
                
                if (totalTimeRemaining > 0) totalTimeRemaining--;
                updateTotalTimeDisplay(totalTimeRemaining);
                
                if (secondsRemaining <= 3 && secondsRemaining > 0) {
                    speak(secondsRemaining.toString());
                }
            }
        }

        function nextPhase() {
            if (!timer) return;
            // If manually skipping, cancel current loop frame to prevent double-fire
            if (timer) cancelAnimationFrame(timer);
            
            // If skipping manually (time left on clock), deduct it from total remaining
            if (secondsRemaining > 0) {
                totalTimeRemaining -= secondsRemaining;
                if (totalTimeRemaining < 0) totalTimeRemaining = 0;
                updateTotalTimeDisplay(totalTimeRemaining);
            }
            
            if (currentPhase === 'prepare') { currentPhase = 'work'; globalIntervalIndex = 0; totalPhaseSeconds = getIntervalData(0).exercise.duration; }
            else if (currentPhase === 'work') { if (getIntervalData(globalIntervalIndex).isLastOverall) { completeWorkout(); return; } currentPhase = 'rest'; totalPhaseSeconds = getSecondsFromTimeInput('input-rest'); }
            else { globalIntervalIndex++; currentPhase = 'work'; totalPhaseSeconds = getIntervalData(globalIntervalIndex).exercise.duration; }
            secondsRemaining = totalPhaseSeconds;
            
            setVisualState(currentPhase);
            timeLeftEl.innerText = formatTime(secondsRemaining);
            updateProgress(100);
            
            if (!isPaused) {
                phaseEndTime = Date.now() + (totalPhaseSeconds * 1000);
                timer = requestAnimationFrame(runTimerLoop);
            } else {
                // If paused, prepare the time for when we eventually resume
                pausedTimeRemainingMs = totalPhaseSeconds * 1000;
            }
        }

        async function startWorkout() {
            exerciseObjects = parseExercises();
            if (exerciseObjects.length === 0) return;
            
            // Clean up any completion animations from previous workout
            exerciseTextEl.classList.remove('pulse-text', 'text-yellow-300', 'text-yellow-400');
            progressCircle.classList.remove('pulse-circle-stroke', 'text-yellow-300', 'text-yellow-400');
            
            // Remove completion glow if it exists
            const completionGlow = document.getElementById('completion-glow');
            if (completionGlow) completionGlow.remove();
            
            await wakeLockManager.enable();
            
            const prep = getSecondsFromTimeInput('input-prepare');
            isPaused = false;
            currentPhase = prep > 0 ? 'prepare' : 'work';
            totalPhaseSeconds = prep > 0 ? prep : getIntervalData(0).exercise.duration;
            secondsRemaining = totalPhaseSeconds;
            phaseEndTime = Date.now() + (totalPhaseSeconds * 1000);
            totalTimeRemaining = calculateTotalTime(); // Initialize total countdown
            
            timeLeftEl.innerText = formatTime(secondsRemaining); 
            updateProgress(100, true); // Fast refill - Set initial progress to full
            updateProgress(100); // Set initial progress to full
            
            setVisualState(currentPhase);
            btnStart.classList.add('hidden');
            btnPause.classList.remove('hidden');
            
            // Start timer AFTER displaying initial state
            if (timer) cancelAnimationFrame(timer);
            timer = requestAnimationFrame(runTimerLoop);
            switchTab('timer');
        }

        async function togglePause() { 
            if (!timer) return; 
            isPaused = !isPaused; 
            
            if (isPaused) {
                cancelAnimationFrame(timer);
                // Calculate exact remaining time to preserve precision
                pausedTimeRemainingMs = phaseEndTime - Date.now();
                
                await wakeLockManager.disable();
                speechManager.cancel();
                btnStart.innerText = "Resume";
            } else {
                // Resume using exact stored time
                phaseEndTime = Date.now() + pausedTimeRemainingMs;
                await wakeLockManager.enable();
                timer = requestAnimationFrame(runTimerLoop);
            }
            
            btnStart.classList.toggle('hidden', !isPaused); 
            btnPause.classList.toggle('hidden', isPaused); 
        }
        
        async function completeWorkout() { 
            clearInterval(timer); 
            cancelAnimationFrame(timer); 
            timer = null; 
            
            await wakeLockManager.disable();
            
            // Visual celebration - synchronized pulsing
            
            // Change text to soft pastel yellow
            exerciseTextEl.innerText = "Amazing!"; 
            exerciseTextEl.classList.remove('text-blue-400', 'text-emerald-500', 'text-orange-500');
            exerciseTextEl.classList.add('text-yellow-300');
            
            // Add pulsing to text
            exerciseTextEl.classList.add('pulse-text');
            
            // Make the circle full (100%) so entire circle glows
            updateProgress(100);
            
            // Make progress circle pulse
            progressCircle.classList.add('pulse-circle-stroke');
            
            // Add circular radial glow behind the circle - soft pastel yellow
            const progressContainer = document.querySelector('.progress-svg-container');
            const glowDiv = document.createElement('div');
            glowDiv.className = 'pulse-radial-glow';
            glowDiv.id = 'completion-glow';
            progressContainer.insertBefore(glowDiv, progressContainer.firstChild);
            
            // Vibration feedback (if supported)
            if (navigator.vibrate) {
                navigator.vibrate([200, 100, 200, 100, 200]);
            }
            
            // Make progress circle soft yellow for completion
            progressCircle.classList.remove('text-blue-500', 'text-emerald-500', 'text-orange-500', 'text-yellow-400');
            progressCircle.classList.add('text-yellow-300');
            
            nextUpContainer.classList.replace('opacity-100', 'opacity-0');
            btnStart.innerText = "Start";
            btnStart.classList.remove('hidden'); 
            btnPause.classList.add('hidden'); 
            speak("Workout complete! Great job!"); 
        }

        // ============================================
        // SOFT RESET FUNCTION (No Page Reload)
        // ============================================
        async function resetTimer() {
            console.log('ðŸ”„ Soft reset initiated');
            
            // Stop and clear timer
            if (timer) {
                clearInterval(timer);
                cancelAnimationFrame(timer);
                timer = null;
            }
            
            // Cleanup resources
            await wakeLockManager.disable();
            speechManager.cancel();
            
            // Reset all state variables
            isPaused = false;
            currentPhase = 'prepare';
            globalIntervalIndex = 0;
            secondsRemaining = 0;
            totalPhaseSeconds = 0;
            exerciseObjects = [];
            
            // Reset UI - Status and Exercise
            exerciseTextEl.innerText = 'Get Ready';
            exerciseTextEl.classList.remove('text-yellow-300', 'text-yellow-400', 'text-blue-400', 'text-emerald-400', 'text-orange-400', 'pulse-text');
            exerciseTextEl.classList.add('text-blue-400');
            
            timeLeftEl.innerText = '00:00';
            updateCountsDisplay();
            
            // Reset total time display
            updateTotalTimeDisplay();
            
            // Reset buttons
            btnStart.innerText = "Start";
            btnStart.classList.remove('hidden');
            btnPause.classList.add('hidden');
            
            // Reset progress circle
            progressCircle.classList.remove('text-emerald-500', 'text-orange-500', 'text-yellow-400', 'text-yellow-300', 'pulse-circle-stroke');
            progressCircle.classList.add('text-blue-500');
            updateProgress(0);
            
            // Remove celebration glow
            const completionGlow = document.getElementById('completion-glow');
            if (completionGlow) completionGlow.remove();
            
            // Switch to timer tab
            switchTab('timer');
            
            console.log('âœ“ Reset complete');
        }

        btnStart.addEventListener('click', () => {
            // Initialize audio subsystems immediately on user interaction
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            speechManager.initialize();

            if (timer && isPaused) {
                togglePause();
            } else {
                startWorkout();
            }
        });
        btnPause.addEventListener('click', togglePause);
        document.getElementById('btn-reset').addEventListener('click', resetTimer);

        // Generic Pointer Events Handler for consistent button feedback across iOS/Android/PC
        document.addEventListener('pointerdown', (e) => {
            const btn = e.target.closest('.ios-button');
            if (!btn) return;

            btn.classList.add('is-pressed');
            try { btn.setPointerCapture(e.pointerId); } catch(e){}

            const clear = (e) => {
                btn.classList.remove('is-pressed');
                try { btn.releasePointerCapture(e.pointerId); } catch(e){}
                ['pointerup', 'pointercancel', 'pointerleave', 'lostpointercapture'].forEach(evt => {
                    btn.removeEventListener(evt, clear);
                });
            };
            
            ['pointerup', 'pointercancel', 'pointerleave', 'lostpointercapture'].forEach(evt => {
                btn.addEventListener(evt, clear);
            });
        });

        progressCircle.style.strokeDasharray = `${CIRCUMFERENCE} ${CIRCUMFERENCE}`;
        window.onload = () => {
            loadSettings();
            renderExerciseList();
            setupAutoSave();
            timeLeftEl.innerText = formatTime(0);
            updateTotalTimeDisplay();
            updateCountsDisplay();
        };

        window.addEventListener('beforeunload', async () => {
            await wakeLockManager.disable();
            speechManager.cancel();
        });
    </script>
</body>
</html>
