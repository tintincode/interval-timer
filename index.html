<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#000000">
    <title>Interval Timer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
    <style>
        :root {
            color-scheme: dark;
            --system-blue: #007AFF;
            --system-emerald: #10b981;
            --system-orange: #f59e0b;
            --system-background: #000000;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background-color: var(--system-background);
            color: #FFFFFF;
            overflow: hidden;
            height: 100dvh;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        .apple-glass {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(30px);
            border: 1px solid rgba(255, 255, 255, 0.15);
        }

        .view-stack {
            position: relative;
            flex: 1;
            width: 100%;
            min-height: 0;
        }

        .tab-view {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black; 
            display: none; 
            flex-direction: column;
            overflow-y: auto;
            z-index: 1;
        }

        .tab-view.active {
            display: flex;
            z-index: 2;
        }

        .progress-ring__circle {
            transition: stroke 0.4s ease;
            transform: rotate(-90deg);
            transform-origin: 50% 50%;
            will-change: stroke-dashoffset;
        }

        .nav-container {
            position: relative;
            display: flex;
            background: rgba(255, 255, 255, 0.06);
            border-radius: 16px;
            padding: 4px;
            margin: 0 24px 24px 24px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            flex-shrink: 0;
        }

        .tab-btn {
            position: relative;
            flex: 1;
            padding: 8px 0;
            font-size: 11px;
            font-weight: 700;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.4);
            z-index: 10;
        }

        .tab-active { color: #FFFFFF; }

        .tab-indicator {
            position: absolute;
            top: 4px;
            left: 4px;
            height: calc(100% - 8px);
            width: calc(50% - 4px);
            background: rgba(255, 255, 255, 0.12);
            border-radius: 12px;
            transition: transform 0.3s cubic-bezier(0.2, 0, 0, 1);
            z-index: 5;
        }

        .ios-button {
            transition: transform 0.2s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.2s, background-color 0.2s;
        }

        .ios-button:active, .ios-button.is-pressed { transform: scale(0.92); opacity: 0.8; }

        /* --- Standardized Pressed States --- */
        #btn-start.is-pressed, #btn-pause.is-pressed { background-color: #d1d5db; }
        #btn-reset.is-pressed, #btn-skip.is-pressed { background-color: rgba(255, 255, 255, 0.2); color: white; }
        #btn-mute.is-pressed { background-color: rgba(255, 255, 255, 0.15); }
        .add-exercise-btn.is-pressed { background-color: rgba(255, 255, 255, 0.2); color: white; }
        
        /* For Routine & Export/Import buttons */
        .ios-button.bg-emerald-500\/10.is-pressed { background-color: rgba(16, 185, 129, 0.25) !important; }
        .ios-button.bg-blue-500\/10.is-pressed { background-color: rgba(59, 130, 246, 0.25) !important; }
        .ios-button.bg-gray-500\/10.is-pressed { background-color: rgba(107, 114, 128, 0.25) !important; }
        .ios-button.bg-red-500\/10.is-pressed { background-color: rgba(239, 68, 68, 0.25) !important; }
        .ios-button.bg-white\/5.is-pressed { background-color: rgba(255, 255, 255, 0.15) !important; }

        @keyframes pulseBig {
            0%, 100% { 
                transform: scale(1);
            }
            50% { 
                transform: scale(1.15);
            }
        }

        @keyframes pulseCircleGlow {
            0%, 100% { 
                stroke-width: 10;
                opacity: 0.7;
            }
            50% { 
                stroke-width: 12;
                opacity: 0.9;
            }
        }
        
        @keyframes pulseRadialGlow {
            0%, 100% { 
                opacity: 0.2;
                transform: scale(1);
            }
            50% { 
                opacity: 0.4;
                transform: scale(1.1);
            }
        }

        .pulse-text {
            animation: pulseBig 1s ease-in-out infinite;
        }

        .pulse-circle-stroke {
            animation: pulseCircleGlow 1s ease-in-out infinite;
        }
        
        .pulse-radial-glow {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(253, 224, 71, 0.25) 0%, rgba(253, 224, 71, 0.15) 30%, rgba(253, 224, 71, 0.06) 50%, rgba(253, 224, 71, 0.02) 70%, transparent 85%);
            animation: pulseRadialGlow 1s ease-in-out infinite;
            pointer-events: none;
            z-index: 1;
            filter: blur(12px);
        }

        @media (max-height: 700px) {
            header { padding-top: 1.5rem !important; margin-bottom: 0.5rem !important; }
            .nav-container { margin-bottom: 1rem !important; margin-left: 1.5rem !important; margin-right: 1.5rem !important; }
            #time-left { font-size: 4.5rem !important; }
            #current-exercise { font-size: 1.5rem !important; }
            .progress-svg-container { max-width: 260px !important; }
            .media-controls { margin-top: 0.5rem !important; gap: 1rem !important; }
            .exercise-label-container { height: 52px !important; }
            #view-timer { gap: 1rem !important; }
        }

        @media (max-width: 400px) {
            .progress-svg-container { 
                max-width: 340px !important; 
            }
            .exercise-label-container {
                width: 220px !important;
            }
            #current-exercise {
                font-size: 1.5rem !important;
            }
        }

        .exercise-label-container {
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 240px;
            overflow: hidden;
        }
        
        #current-exercise {
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.3;
            max-width: 100%;
            text-align: center;
            white-space: normal;
            word-break: break-word;
        }

        .exercise-row.dragging {
            opacity: 0.5;
            transform: scale(0.98);
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            pointer-events: none; /* Allows elementFromPoint to see what's underneath */
            transition: none;
        }

        .exercise-row.ghost {
            position: fixed;
            z-index: 1000;
            pointer-events: none;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            opacity: 1;
            background: #000;
            border-radius: 12px;
        }
        .exercise-row.placeholder {
            opacity: 0 !important;
        }
        
        .delete-btn {
            transition: all 0.2s;
            /* Note: .is-pressed state is now handled by the generic .ios-button.bg-white/5 rule */
        }

        #routine-select option {
            background-color: #1d1d1f;
            color: #ffffff;
        }

        #ac-ls-dropdown-select svg {
            transition: transform 0.2s;
        }

        /* Settings page polish */
        #view-settings {
            scrollbar-width: none;
        }
        #view-settings::-webkit-scrollbar {
            display: none;
        }

        /* Interval rows â€” subtle hover lift on mobile */
        #view-settings .apple-glass .ios-button:not(.add-exercise-btn):active {
            background-color: rgba(255,255,255,0.04);
        }

        /* Settings card row dividers via divide utility */
        .settings-row {
            transition: background-color 0.15s ease;
        }
        .settings-row:active {
            background-color: rgba(255,255,255,0.04);
        }

        /* Smooth focus highlight on time inputs */
        #view-settings input:focus {
            color: #ffffff;
        }

        /* Interval row value display */
        .value-display {
            color: rgba(255,255,255,0.9);
            transition: color 0.2s;
        }
        .value-display:focus {
            color: #60a5fa; /* blue-400 */
        }

        /* Dim secondary rows when value is zero */
        .interval-row.is-zero {
            opacity: 0.45;
        }
        .interval-row.is-zero .value-display {
            color: rgba(255,255,255,0.3);
        }

        /* Primary rows get a very faint tint */
        .interval-row.bg-white\/\[0\.03\] {
            background-color: rgba(255,255,255,0.03);
        }

        /* Add exercise dashed border pulse on hover */
        .add-exercise-btn:hover {
            border-color: rgba(255,255,255,0.3);
            color: rgba(255,255,255,0.6);
        }

        /* Slide-in animation when opening settings */
        #view-settings.active {
            animation: slideInFromRight 0.28s cubic-bezier(0.25, 0.46, 0.45, 0.94) both;
        }

        @keyframes slideInFromRight {
            from {
                opacity: 0;
                transform: translateX(24px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
    </style>
</head>
<body>

    <div class="max-w-md w-full h-full flex flex-col relative overflow-hidden">
        
        <header class="flex justify-between items-center px-4 md:px-8 pt-10 mb-3 flex-shrink-0">
            <button onclick="switchTab('settings')" class="ios-button flex items-center justify-center h-12 w-12 rounded-2xl apple-glass border-white/5 shadow-xl text-white/70">
                <svg xmlns="http://www.w3.org/2000/svg" class="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                </svg>
            </button>
            <button id="btn-mute" onclick="toggleMute()" class="ios-button flex items-center justify-center h-12 w-12 rounded-2xl apple-glass border-white/5 shadow-xl">
                <svg id="icon-unmuted" xmlns="http://www.w3.org/2000/svg" class="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" />
                </svg>
                <svg id="icon-muted" xmlns="http://www.w3.org/2000/svg" class="w-6 h-6 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M18.364 18.364A9 9 0 005.636 5.636m12.728 12.728A9 9 0 015.636 5.636m12.728 12.728L5.636 5.636" />
                </svg>
            </button>
        </header>

        <div class="view-stack">
            <div id="view-timer" class="tab-view active pb-8 flex flex-col gap-6 justify-center h-full">
                <div class="relative w-full flex items-center justify-center px-4">
                    <div class="progress-svg-container relative w-full max-w-[360px] aspect-square flex items-center justify-center">
                        <svg class="absolute inset-0 w-full h-full z-0" viewBox="0 0 320 320">
                            <circle class="text-white/5" stroke-width="12" stroke="currentColor" fill="transparent" r="148" cx="160" cy="160" />
                            <circle id="progress-circle" class="progress-ring__circle text-blue-500" stroke-width="12" stroke-dasharray="930" stroke-dashoffset="0" stroke-linecap="round" stroke="currentColor" fill="transparent" r="148" cx="160" cy="160" />
                        </svg>
                        <div class="relative z-10 flex flex-col items-center justify-center text-center select-none p-4 w-full">
                            <div class="exercise-label-container">
                                <span id="current-exercise" class="text-blue-400 font-black tracking-wide uppercase text-3xl">Get Ready</span>
                            </div>
                            <span id="time-left" class="text-[5rem] font-black tracking-tighter tabular-nums leading-none mt-1">00:00</span>
                            <div class="mt-3 flex flex-col items-center min-h-[68px]">
                                <span id="circuit-display" class="text-sm font-bold text-blue-500/50 uppercase tracking-[0.2em] tabular-nums"> </span>
                                <span id="round-display" class="text-sm font-bold text-white/30 uppercase tracking-[0.2em] mt-1 tabular-nums">Ready</span>
                                <span id="total-time-display" class="text-sm font-bold text-white/60 uppercase tracking-[0.2em] mt-1 transition-opacity duration-300 tabular-nums">Total: --:--</span>
                                <div id="total-progress-bar-container" class="w-28 h-1.5 bg-white/10 rounded-full overflow-hidden mt-2 transition-opacity duration-300">
                                    <div id="total-progress-bar" class="h-full bg-blue-500 w-0 shadow-[0_0_10px_rgba(59,130,246,0.5)]"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="next-up-container" class="flex flex-col items-center justify-center opacity-0 transition-all duration-500">
                    <div class="flex items-center gap-2">
                        <span class="text-[8px] font-black text-white/20 uppercase tracking-[0.5em]">Next</span>
                        <span id="next-exercise-name" class="text-lg font-bold text-white/60 uppercase tracking-widest text-center">---</span>
                    </div>
                </div>

                <div class="media-controls w-full px-4 flex items-center justify-center gap-6 mt-2">
                    <button id="btn-reset" class="ios-button h-20 w-20 bg-white/5 text-white/70 rounded-full flex items-center justify-center border border-white/15 backdrop-blur-md font-semibold text-xs uppercase tracking-wider transition-all">
                        Reset
                    </button>
                    <div class="relative h-24 w-24">
                        <button id="btn-start" class="ios-button absolute inset-0 bg-white text-black rounded-full flex items-center justify-center shadow-2xl font-bold text-lg uppercase tracking-wide">
                            Start
                        </button>
                        <button id="btn-pause" class="ios-button hidden absolute inset-0 bg-white text-black rounded-full flex items-center justify-center shadow-2xl font-bold text-sm uppercase tracking-wide">
                            Pause
                        </button>
                    </div>
                    <button id="btn-skip" onclick="nextPhase(true)" class="ios-button h-20 w-20 bg-white/5 text-white/70 rounded-full flex items-center justify-center border border-white/15 backdrop-blur-md font-semibold text-xs uppercase tracking-wider transition-all">
                        Skip
                    </button>
                </div>
            </div>

            <div id="view-settings" class="tab-view px-4 md:px-8 pb-12">

                <!-- Page header -->
                <div class="flex justify-between items-center pt-4 pb-5 px-1">
                    <h2 class="text-3xl font-black text-white tracking-tight">Settings</h2>
                    <button onclick="switchTab('timer'); showSettingsSaved()" class="ios-button bg-blue-600 text-white px-5 py-2 rounded-full text-sm font-bold tracking-wide transition-colors shadow-lg shadow-blue-900/30">Done</button>
                </div>

                <div class="space-y-3">

                    <!-- â”€â”€ INTERVALS â”€â”€ -->
                    <div>
                        <p class="text-[11px] font-black text-white/30 uppercase tracking-[0.18em] mb-2 px-1">Intervals</p>
                        <div class="apple-glass rounded-[20px] overflow-hidden">
                        <div id="row-work" class="interval-row bg-white/[0.03] flex items-center px-4 py-3 gap-3 transition-colors duration-200">
                            <div class="w-8 h-8 rounded-xl bg-emerald-500/15 flex items-center justify-center flex-shrink-0">
                                <svg class="w-4 h-4 text-emerald-400" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M13 10V3L4 14h7v7l9-11h-7z"/></svg>
                            </div>
                            <div class="flex-1 min-w-0">
                                <p class="text-[13px] font-semibold text-white leading-tight">Exercise</p>
                                <p class="text-[11px] text-white/30 leading-tight mt-0.5">default duration per exercise</p>
                            </div>
                            <div class="flex items-center bg-white/5 rounded-2xl border border-white/10 overflow-hidden flex-shrink-0">
                                <button class="ios-button w-11 h-11 flex items-center justify-center text-white/50 hover:text-white/80 hover:bg-white/8 transition-colors flex-shrink-0"
                                    ontouchstart="startTimeDecrement('input-work', event)" ontouchend="stopAdjustment()"
                                    onmousedown="if(!('ontouchstart' in window)) startTimeDecrement('input-work', event)" onmouseup="stopAdjustment()" onmouseleave="stopAdjustment()">
                                    <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" stroke-width="3" viewBox="0 0 24 24"><path stroke-linecap="round" d="M20 12H4"/></svg>
                                </button>
                                <div class="w-px h-5 bg-white/10 flex-shrink-0"></div>
                                <input type="text" id="input-work" value="00:45" data-seconds="45"
                                    onclick="this.select()" onblur="handleTimeBlur('input-work'); updateIntervalRowDim('input-work')"
                                    class="w-16 bg-transparent text-base font-black text-center outline-none tabular-nums value-display py-0">
                                <div class="w-px h-5 bg-white/10 flex-shrink-0"></div>
                                <button class="ios-button w-11 h-11 flex items-center justify-center text-white/50 hover:text-white/80 hover:bg-white/8 transition-colors flex-shrink-0"
                                    ontouchstart="startTimeIncrement('input-work', event)" ontouchend="stopAdjustment()"
                                    onmousedown="if(!('ontouchstart' in window)) startTimeIncrement('input-work', event)" onmouseup="stopAdjustment()" onmouseleave="stopAdjustment()">
                                    <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" stroke-width="3" viewBox="0 0 24 24"><path stroke-linecap="round" d="M12 4v16m8-8H4"/></svg>
                                </button>
                            </div>
                        </div>
                            <div class="border-t border-white/[0.07] mx-4"></div>
                        <div id="row-rest" class="interval-row bg-white/[0.03] flex items-center px-4 py-3 gap-3 transition-colors duration-200">
                            <div class="w-8 h-8 rounded-xl bg-orange-500/15 flex items-center justify-center flex-shrink-0">
                                <svg class="w-4 h-4 text-orange-400" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"/></svg>
                            </div>
                            <div class="flex-1 min-w-0">
                                <p class="text-[13px] font-semibold text-white leading-tight">Rest</p>
                                <p class="text-[11px] text-white/30 leading-tight mt-0.5">between exercises</p>
                            </div>
                            <div class="flex items-center bg-white/5 rounded-2xl border border-white/10 overflow-hidden flex-shrink-0">
                                <button class="ios-button w-11 h-11 flex items-center justify-center text-white/50 hover:text-white/80 hover:bg-white/8 transition-colors flex-shrink-0"
                                    ontouchstart="startTimeDecrement('input-rest', event)" ontouchend="stopAdjustment()"
                                    onmousedown="if(!('ontouchstart' in window)) startTimeDecrement('input-rest', event)" onmouseup="stopAdjustment()" onmouseleave="stopAdjustment()">
                                    <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" stroke-width="3" viewBox="0 0 24 24"><path stroke-linecap="round" d="M20 12H4"/></svg>
                                </button>
                                <div class="w-px h-5 bg-white/10 flex-shrink-0"></div>
                                <input type="text" id="input-rest" value="00:15" data-seconds="15"
                                    onclick="this.select()" onblur="handleTimeBlur('input-rest'); updateIntervalRowDim('input-rest')"
                                    class="w-16 bg-transparent text-base font-black text-center outline-none tabular-nums value-display py-0">
                                <div class="w-px h-5 bg-white/10 flex-shrink-0"></div>
                                <button class="ios-button w-11 h-11 flex items-center justify-center text-white/50 hover:text-white/80 hover:bg-white/8 transition-colors flex-shrink-0"
                                    ontouchstart="startTimeIncrement('input-rest', event)" ontouchend="stopAdjustment()"
                                    onmousedown="if(!('ontouchstart' in window)) startTimeIncrement('input-rest', event)" onmouseup="stopAdjustment()" onmouseleave="stopAdjustment()">
                                    <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" stroke-width="3" viewBox="0 0 24 24"><path stroke-linecap="round" d="M12 4v16m8-8H4"/></svg>
                                </button>
                            </div>
                        </div>
                            <div class="border-t-2 border-white/[0.05] mx-4 my-0.5"></div>
                        <div id="row-circuits" class="interval-row flex items-center px-4 py-3 gap-3 transition-colors duration-200">
                            <div class="w-8 h-8 rounded-xl bg-blue-500/15 flex items-center justify-center flex-shrink-0">
                                <svg class="w-4 h-4 text-blue-400" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/></svg>
                            </div>
                            <div class="flex-1 min-w-0">
                                <p class="text-[13px] font-semibold text-white leading-tight">Circuits</p>
                                <p class="text-[11px] text-white/30 leading-tight mt-0.5">full rounds through all exercises</p>
                            </div>
                            <div class="flex items-center bg-white/5 rounded-2xl border border-white/10 overflow-hidden flex-shrink-0">
                                <button class="ios-button w-11 h-11 flex items-center justify-center text-white/50 hover:text-white/80 hover:bg-white/8 transition-colors flex-shrink-0"
                                    ontouchstart="startDecrement('input-rounds')" ontouchend="stopAdjustment()"
                                    onmousedown="if(!('ontouchstart' in window)) startDecrement('input-rounds')" onmouseup="stopAdjustment()" onmouseleave="stopAdjustment()">
                                    <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" stroke-width="3" viewBox="0 0 24 24"><path stroke-linecap="round" d="M20 12H4"/></svg>
                                </button>
                                <div class="w-px h-5 bg-white/10 flex-shrink-0"></div>
                                <input type="text" inputmode="numeric" pattern="[0-9]*" id="input-rounds" value="3"
                                    onclick="this.select()"
                                    class="w-16 bg-transparent text-base font-black text-center outline-none tabular-nums value-display py-0">
                                <div class="w-px h-5 bg-white/10 flex-shrink-0"></div>
                                <button class="ios-button w-11 h-11 flex items-center justify-center text-white/50 hover:text-white/80 hover:bg-white/8 transition-colors flex-shrink-0"
                                    ontouchstart="startIncrement('input-rounds')" ontouchend="stopAdjustment()"
                                    onmousedown="if(!('ontouchstart' in window)) startIncrement('input-rounds')" onmouseup="stopAdjustment()" onmouseleave="stopAdjustment()">
                                    <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" stroke-width="3" viewBox="0 0 24 24"><path stroke-linecap="round" d="M12 4v16m8-8H4"/></svg>
                                </button>
                            </div>
                        </div>
                            <div class="border-t border-white/[0.07] mx-4"></div>
                        <div id="row-prepare" class="interval-row flex items-center px-4 py-3 gap-3 transition-colors duration-200">
                            <div class="w-8 h-8 rounded-xl bg-blue-400/10 flex items-center justify-center flex-shrink-0">
                                <svg class="w-4 h-4 text-blue-300" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>
                            </div>
                            <div class="flex-1 min-w-0">
                                <p class="text-[13px] font-semibold text-white leading-tight">Get Ready</p>
                                <p class="text-[11px] text-white/30 leading-tight mt-0.5">countdown before workout starts</p>
                            </div>
                            <div class="flex items-center bg-white/5 rounded-2xl border border-white/10 overflow-hidden flex-shrink-0">
                                <button class="ios-button w-11 h-11 flex items-center justify-center text-white/50 hover:text-white/80 hover:bg-white/8 transition-colors flex-shrink-0"
                                    ontouchstart="startTimeDecrement('input-prepare', event)" ontouchend="stopAdjustment()"
                                    onmousedown="if(!('ontouchstart' in window)) startTimeDecrement('input-prepare', event)" onmouseup="stopAdjustment()" onmouseleave="stopAdjustment()">
                                    <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" stroke-width="3" viewBox="0 0 24 24"><path stroke-linecap="round" d="M20 12H4"/></svg>
                                </button>
                                <div class="w-px h-5 bg-white/10 flex-shrink-0"></div>
                                <input type="text" id="input-prepare" value="00:10" data-seconds="10"
                                    onclick="this.select()" onblur="handleTimeBlur('input-prepare'); updateIntervalRowDim('input-prepare')"
                                    class="w-16 bg-transparent text-base font-black text-center outline-none tabular-nums value-display py-0">
                                <div class="w-px h-5 bg-white/10 flex-shrink-0"></div>
                                <button class="ios-button w-11 h-11 flex items-center justify-center text-white/50 hover:text-white/80 hover:bg-white/8 transition-colors flex-shrink-0"
                                    ontouchstart="startTimeIncrement('input-prepare', event)" ontouchend="stopAdjustment()"
                                    onmousedown="if(!('ontouchstart' in window)) startTimeIncrement('input-prepare', event)" onmouseup="stopAdjustment()" onmouseleave="stopAdjustment()">
                                    <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" stroke-width="3" viewBox="0 0 24 24"><path stroke-linecap="round" d="M12 4v16m8-8H4"/></svg>
                                </button>
                            </div>
                        </div>
                            <div class="border-t border-white/[0.07] mx-4"></div>
                        <div id="row-cooldown" class="interval-row flex items-center px-4 py-3 gap-3 transition-colors duration-200">
                            <div class="w-8 h-8 rounded-xl bg-teal-500/15 flex items-center justify-center flex-shrink-0">
                                <svg class="w-4 h-4 text-teal-400" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"/></svg>
                            </div>
                            <div class="flex-1 min-w-0">
                                <p class="text-[13px] font-semibold text-white leading-tight">Cool Down</p>
                                <p class="text-[11px] text-white/30 leading-tight mt-0.5">relaxed phase after last exercise</p>
                            </div>
                            <div class="flex items-center bg-white/5 rounded-2xl border border-white/10 overflow-hidden flex-shrink-0">
                                <button class="ios-button w-11 h-11 flex items-center justify-center text-white/50 hover:text-white/80 hover:bg-white/8 transition-colors flex-shrink-0"
                                    ontouchstart="startTimeDecrement('input-cooldown', event)" ontouchend="stopAdjustment()"
                                    onmousedown="if(!('ontouchstart' in window)) startTimeDecrement('input-cooldown', event)" onmouseup="stopAdjustment()" onmouseleave="stopAdjustment()">
                                    <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" stroke-width="3" viewBox="0 0 24 24"><path stroke-linecap="round" d="M20 12H4"/></svg>
                                </button>
                                <div class="w-px h-5 bg-white/10 flex-shrink-0"></div>
                                <input type="text" id="input-cooldown" value="00:00" data-seconds="0"
                                    onclick="this.select()" onblur="handleTimeBlur('input-cooldown'); updateIntervalRowDim('input-cooldown')"
                                    class="w-16 bg-transparent text-base font-black text-center outline-none tabular-nums value-display py-0">
                                <div class="w-px h-5 bg-white/10 flex-shrink-0"></div>
                                <button class="ios-button w-11 h-11 flex items-center justify-center text-white/50 hover:text-white/80 hover:bg-white/8 transition-colors flex-shrink-0"
                                    ontouchstart="startTimeIncrement('input-cooldown', event)" ontouchend="stopAdjustment()"
                                    onmousedown="if(!('ontouchstart' in window)) startTimeIncrement('input-cooldown', event)" onmouseup="stopAdjustment()" onmouseleave="stopAdjustment()">
                                    <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" stroke-width="3" viewBox="0 0 24 24"><path stroke-linecap="round" d="M12 4v16m8-8H4"/></svg>
                                </button>
                            </div>
                        </div>
                        </div>
                    </div>

                    <!-- â”€â”€ EXERCISES â”€â”€ -->
                    <div>
                        <div class="flex justify-between items-baseline mb-2 px-1">
                            <p class="text-[11px] font-black text-white/30 uppercase tracking-[0.18em]">Exercises</p>
                            <span class="text-[10px] text-white/20 font-semibold uppercase tracking-wider">Duration (Optional)</span>
                        </div>
                        <div class="apple-glass rounded-[20px] p-4 space-y-2">
                            <div id="exercises-list" class="space-y-2"></div>
                            <button onclick="addNewExerciseRow()" class="add-exercise-btn ios-button w-full py-3 rounded-xl bg-white/5 border border-dashed border-white/15 text-xs font-bold uppercase tracking-wider text-white/40 transition-all flex items-center justify-center gap-2 mt-1">
                                <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-width="2.5" d="M12 4v16m8-8H4"/></svg>
                                Add Exercise
                            </button>
                        </div>
                    </div>

                    <!-- â”€â”€ AUDIO â”€â”€ -->
                    <div>
                        <p class="text-[11px] font-black text-white/30 uppercase tracking-[0.18em] mb-2 px-1">Audio</p>
                        <div class="apple-glass rounded-[20px] overflow-hidden divide-y divide-white/[0.07]">
                            <button id="btn-audio-voice" onclick="setAudioType('voice')"
                                class="ios-button flex items-center justify-between w-full px-4 py-3.5 transition-colors">
                                <div class="flex items-center gap-3">
                                    <div class="w-8 h-8 rounded-xl bg-blue-500/15 flex items-center justify-center flex-shrink-0">
                                        <svg class="w-4 h-4 text-blue-400" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z"/></svg>
                                    </div>
                                    <div class="text-left">
                                        <p class="text-sm font-semibold text-white">Voice</p>
                                        <p class="text-[11px] text-white/30">Spoken exercise names &amp; countdowns</p>
                                    </div>
                                </div>
                                <span id="audio-voice-check" class="text-blue-400 ml-3 flex-shrink-0">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2.5" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7"/></svg>
                                </span>
                            </button>
                            <button id="btn-audio-beep" onclick="setAudioType('beep')"
                                class="ios-button flex items-center justify-between w-full px-4 py-3.5 transition-colors">
                                <div class="flex items-center gap-3">
                                    <div class="w-8 h-8 rounded-xl bg-orange-500/15 flex items-center justify-center flex-shrink-0">
                                        <svg class="w-4 h-4 text-orange-400" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3"/></svg>
                                    </div>
                                    <div class="text-left">
                                        <p class="text-sm font-semibold text-white">Beep</p>
                                        <p class="text-[11px] text-white/30">Tones for phase changes &amp; countdown</p>
                                    </div>
                                </div>
                                <span id="audio-beep-check" class="text-blue-400 ml-3 flex-shrink-0 hidden">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2.5" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7"/></svg>
                                </span>
                            </button>
                        </div>
                    </div>

                    <!-- â”€â”€ ROUTINES â”€â”€ -->
                    <div>
                        <p class="text-[11px] font-black text-white/30 uppercase tracking-[0.18em] mb-2 px-1">Saved Routines</p>
                        <div class="apple-glass rounded-[20px] overflow-hidden relative z-20">
                            <!-- Routine selector -->
                            <div class="p-4 space-y-3">
                                <div class="relative" id="custom-routine-dropdown">
                                    <button id="ac-ls-dropdown-select" onclick="toggleDropdown()" class="w-full flex items-center justify-between bg-white/5 hover:bg-white/8 border border-white/10 rounded-xl pl-4 pr-3 py-3 text-sm font-medium text-white transition-colors outline-none">
                                        <span id="ac-ls-dropdown-title" class="truncate text-white/60">Select Routine</span>
                                        <svg class="w-3.5 h-3.5 text-white/30 ml-2 transition-transform" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"/></svg>
                                    </button>
                                    <div id="ac-ls-dropdown-options" class="absolute left-0 right-0 top-full mt-1 bg-[#1a1a1c] border border-white/10 rounded-xl shadow-2xl overflow-hidden hidden z-50 max-h-60 overflow-y-auto">
                                        <ul id="ac-ls-dropdown-options-list" class="py-1"></ul>
                                    </div>
                                </div>
                                <div class="grid grid-cols-2 gap-2">
                                    <button id="btn-update-routine" onclick="updateRoutine()" class="ios-button bg-emerald-500/10 border border-emerald-500/20 rounded-xl py-2.5 text-xs font-bold uppercase tracking-wider text-emerald-400 transition-all opacity-40 pointer-events-none">Update</button>
                                    <button onclick="saveRoutine()" class="ios-button bg-blue-500/10 border border-blue-500/20 rounded-xl py-2.5 text-xs font-bold uppercase tracking-wider text-blue-400 transition-colors">Save New</button>
                                    <button id="btn-rename-routine" onclick="renameRoutine()" class="ios-button bg-white/5 border border-white/10 rounded-xl py-2.5 text-xs font-bold uppercase tracking-wider text-white/40 transition-all opacity-40 pointer-events-none">Rename</button>
                                    <button onclick="deleteRoutine()" class="ios-button bg-red-500/10 border border-red-500/20 rounded-xl py-2.5 text-xs font-bold uppercase tracking-wider text-red-400 transition-colors">Delete</button>
                                </div>
                            </div>
                            <!-- Backup/Restore -->
                            <div class="border-t border-white/[0.07] flex">
                                <input type="file" id="import-file" accept=".json" class="hidden" onchange="handleFileImport(this)">
                                <button onclick="exportRoutines()" class="flex-1 ios-button py-3 text-xs font-bold uppercase tracking-wider text-white/30 hover:text-white/50 transition-colors border-r border-white/[0.07] flex items-center justify-center gap-2">
                                    <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/></svg>
                                    Backup
                                </button>
                                <button onclick="document.getElementById('import-file').click()" class="flex-1 ios-button py-3 text-xs font-bold uppercase tracking-wider text-white/30 hover:text-white/50 transition-colors flex items-center justify-center gap-2">
                                    <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l4-4m0 0l4 4m-4-4v12"/></svg>
                                    Restore
                                </button>
                            </div>
                        </div>
                    </div>

                </div>
            </div>
                </div>
            </div>
        </div>

        <div id="message-box" class="fixed top-8 left-1/2 -translate-x-1/2 px-8 py-3 rounded-full apple-glass text-white font-black text-[10px] shadow-2xl transition-all opacity-0 pointer-events-none z-50 uppercase tracking-widest">Workout Complete</div>
    
        <!-- Custom Modal -->
        <div id="custom-modal" class="absolute inset-0 z-[100] flex items-center justify-center bg-black/60 backdrop-blur-sm hidden opacity-0 transition-opacity duration-300">
            <div id="modal-content" class="apple-glass p-6 rounded-[24px] w-[85%] max-w-xs transform scale-95 transition-transform duration-300 flex flex-col gap-4 shadow-2xl">
                <h3 id="modal-title" class="text-lg font-bold text-white text-center">Title</h3>
                <p id="modal-message" class="text-sm text-white/60 text-center leading-relaxed hidden">Message</p>
                <input id="modal-input" type="text" class="w-full bg-white/10 border border-white/10 rounded-xl px-4 py-3 text-base text-white outline-none focus:bg-white/15 transition-colors hidden" autocomplete="off">
                <div class="grid grid-cols-2 gap-3 mt-2" id="modal-buttons">
                    <button id="modal-cancel" class="ios-button bg-white/5 hover:bg-white/10 rounded-xl py-3 text-sm font-semibold text-white/60">Cancel</button>
                    <button id="modal-confirm" class="ios-button bg-blue-500 hover:bg-blue-600 text-white rounded-xl py-3 text-sm font-semibold">OK</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // WAKE LOCK MANAGER
        // ============================================
        class WakeLockManager {
            constructor() {
                this.wakeLock = null;
                this.isSupported = 'wakeLock' in navigator;
            }

            async enable() {
                if (!this.isSupported) {
                    console.warn('Wake Lock API is not supported in this browser');
                    return;
                }

                try {
                    this.wakeLock = await navigator.wakeLock.request('screen');
                    console.log('âœ“ Wake Lock enabled - screen will stay on');
                    
                    this.wakeLock.addEventListener('release', () => {
                        console.log('Wake Lock was released');
                    });
                } catch (err) {
                    console.error('Failed to enable Wake Lock:', err);
                }
            }

            async disable() {
                if (this.wakeLock) {
                    try {
                        await this.wakeLock.release();
                        this.wakeLock = null;
                        console.log('âœ“ Wake Lock disabled');
                    } catch (err) {
                        console.error('Error releasing Wake Lock:', err);
                    }
                }
            }

            async reEnable() {
                if (this.wakeLock !== null || this.isSupported) {
                    await this.disable();
                    await this.enable();
                }
            }
        }

        const wakeLockManager = new WakeLockManager();

        // ============================================
        // SPEECH SYNTHESIS MANAGER (iOS-Compatible)
        // ============================================
        class SpeechManager {
            constructor() {
                this.isInitialized = false;
                this.isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            }

            initialize() {
                if (this.isInitialized) return;
                
                if (this.isIOS && 'speechSynthesis' in window) {
                    const utterance = new SpeechSynthesisUtterance(' ');
                    utterance.volume = 0;
                    window.speechSynthesis.speak(utterance);
                    this.isInitialized = true;
                    console.log('âœ“ Speech synthesis initialized for iOS');
                } else {
                    this.isInitialized = true;
                }
            }

            speak(text, voiceEnabled) {
                if (!voiceEnabled) return;
                
                if (!this.isInitialized) {
                    this.initialize();
                }

                window.speechSynthesis.cancel();

                setTimeout(() => {
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.rate = 1.1;
                    utterance.volume = 1.0;
                    utterance.lang = 'en-US';
                    
                    if (this.isIOS) {
                        utterance.rate = 1.0;
                    }
                    
                    window.speechSynthesis.speak(utterance);
                    console.log('ðŸ”Š Speaking:', text);
                }, this.isIOS ? 100 : 0);
            }

            cancel() {
                window.speechSynthesis.cancel();
            }
        }

        const speechManager = new SpeechManager();

        // ============================================
        // SOUND MANAGER (Beeps via Web Audio API)
        // ============================================
        class SoundManager {
            constructor() {
                this.ctx = null;
            }

            // Must be called inside a user gesture (button click) every time Start is pressed.
            // Creates the AudioContext on first call; resumes it on every subsequent call
            // so it is never silently suspended (browsers can suspend it after inactivity).
            async unlock() {
                try {
                    if (!this.ctx) {
                        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    if (this.ctx.state !== 'running') {
                        await this.ctx.resume();
                    }
                    // iOS Safari requires a real buffer playback inside the gesture handler
                    // to fully activate the audio hardware.
                    const buf = this.ctx.createBuffer(1, 1, this.ctx.sampleRate);
                    const src = this.ctx.createBufferSource();
                    src.buffer = buf;
                    src.connect(this.ctx.destination);
                    src.start(0);
                    console.log('âœ“ Web Audio ready, state:', this.ctx.state);
                } catch (e) {
                    console.error('Audio unlock failed:', e);
                }
            }

            // Internal: schedule a single tone at a precise AudioContext time.
            // `when` should always be ctx.currentTime + some lookahead (never just currentTime).
            _tone(freq, duration, vol, when) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.type = 'sine';
                osc.frequency.value = freq;
                // Short attack, exponential decay envelope
                gain.gain.setValueAtTime(0, when);
                gain.gain.linearRampToValueAtTime(vol, when + 0.008);
                gain.gain.exponentialRampToValueAtTime(0.001, when + duration);
                osc.start(when);
                osc.stop(when + duration + 0.02);
            }

            // Public: play a sequence of tones.
            // `notes` is an array of { freq, duration, vol, delay }
            // All delays are relative to now + a fixed 80ms lookahead.
            // 80ms is enough to be reliable on both iOS and PC, but short enough to feel instant.
            _play(notes) {
                if (!this.ctx) {
                    console.warn('AudioContext not ready.');
                    return;
                }
                if (this.ctx.state === 'suspended') {
                    // Shouldn't normally happen (unlock() is called on every Start press),
                    // but handle gracefully just in case.
                    this.ctx.resume().then(() => this._scheduleNotes(notes));
                } else {
                    this._scheduleNotes(notes);
                }
            }

            _scheduleNotes(notes) {
                // Snapshot currentTime ONCE so all notes in a sequence are relative to
                // the same reference point, regardless of JS execution time between calls.
                const base = this.ctx.currentTime + 0.08;
                notes.forEach(({ freq, duration, vol, delay = 0 }) => {
                    this._tone(freq, duration, vol, base + delay);
                });
            }

            playPrepare() {
                // Single rising two-tone: clearly signals "get ready"
                this._play([
                    { freq: 500, duration: 0.12, vol: 0.3,  delay: 0    },
                    { freq: 750, duration: 0.15, vol: 0.35, delay: 0.18 },
                ]);
            }

            playCountdown() {
                // Short high tick
                this._play([{ freq: 1200, duration: 0.1, vol: 0.3 }]);
            }

            playWorkStart() {
                // Double beep â€” "Go!"
                this._play([
                    { freq: 880, duration: 0.15, vol: 0.4, delay: 0    },
                    { freq: 880, duration: 0.15, vol: 0.4, delay: 0.22 },
                ]);
            }

            playRestStart() {
                // Single low tone â€” "Rest"
                this._play([{ freq: 400, duration: 0.25, vol: 0.3 }]);
            }

            playComplete() {
                // Rising victory sequence
                this._play([
                    { freq: 700,  duration: 0.12, vol: 0.3,  delay: 0    },
                    { freq: 900,  duration: 0.12, vol: 0.3,  delay: 0.17 },
                    { freq: 1100, duration: 0.2,  vol: 0.35, delay: 0.34 },
                ]);
            }
        }

        const soundManager = new SoundManager();

        // ============================================
        // TIMER CODE
        // ============================================
        const CIRCLE_RADIUS = 148;
        const CIRCUMFERENCE = 2 * Math.PI * CIRCLE_RADIUS;
        let timer = null, isPaused = false, currentPhase = 'prepare', globalIntervalIndex = 0, secondsRemaining = 0, totalPhaseSeconds = 0, totalTimeRemaining = 0, initialTotalTime = 0, exerciseObjects = [], phaseEndTime = 0, pausedTimeRemainingMs = 0, workoutEndTime = 0, pauseStartTime = 0;

        const timeLeftEl = document.getElementById('time-left');
        const roundDisplayEl = document.getElementById('round-display');
        const circuitDisplayEl = document.getElementById('circuit-display');
        const totalTimeDisplayEl = document.getElementById('total-time-display');
        const exerciseTextEl = document.getElementById('current-exercise');
        const totalProgressBar = document.getElementById('total-progress-bar');
        const totalProgressBarContainer = document.getElementById('total-progress-bar-container');
        const progressCircle = document.getElementById('progress-circle');
        const navIndicator = document.getElementById('nav-indicator');
        const btnMute = document.getElementById('btn-mute');
        const iconMuted = document.getElementById('icon-muted');
        const iconUnmuted = document.getElementById('icon-unmuted');
        const btnStart = document.getElementById('btn-start');
        const btnPause = document.getElementById('btn-pause');
        const nextUpContainer = document.getElementById('next-up-container');
        const nextExerciseNameEl = document.getElementById('next-exercise-name');
        const inputWork = document.getElementById('input-work'), inputRest = document.getElementById('input-rest'), inputRounds = document.getElementById('input-rounds'), inputPrepare = document.getElementById('input-prepare');
        
        // Native Data Model (Source of Truth)
        let exercisesData = [
            { name: "Jumping jacks", duration: null },
            { name: "Push ups", duration: 30 },
            { name: "Crunches", duration: null },
            { name: "Walk outs", duration: null },
            { name: "Squats", duration: null },
            { name: "Mountain climbers", duration: null }
        ];
        
        // Voice state variable (controlled by mute button)
        let voiceEnabled = true;
        let audioType = 'voice'; // 'voice' or 'beep'
        
        // ============================================
        // ROUTINE MANAGER
        // ============================================
        let savedRoutines = [];
        let currentRoutineIndex = -1;

        function loadRoutines() {
            const stored = localStorage.getItem('intervalTimerRoutines');
            if (stored) {
                try {
                    savedRoutines = JSON.parse(stored);
                } catch (e) {
                    console.error('Error loading routines', e);
                    savedRoutines = [];
                }
            }
            updateRoutineSelect();
        }

        function updateRoutineSelect() {
            const list = document.getElementById('ac-ls-dropdown-options-list');
            if (!list) return;
            
            list.innerHTML = '';
            
            if (savedRoutines.length === 0) {
                 const li = document.createElement('li');
                 li.className = 'px-3 py-2 text-sm text-white/50 italic';
                 li.textContent = 'No saved routines';
                 list.appendChild(li);
                 return;
            }

            savedRoutines.forEach((routine, index) => {
                const li = document.createElement('li');
                li.className = 'ac-ls-dropdown-option px-3 py-2 text-sm font-medium text-white hover:bg-[#2c2c2e] cursor-pointer flex items-center gap-2';
                li.onclick = () => {
                    loadRoutine(index);
                    toggleDropdown(false);
                };
                li.innerHTML = `<span class="w-3 h-3 flex items-center justify-center text-[#0071e3] ${index === currentRoutineIndex ? '' : 'opacity-0'} check-icon"><svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="2"><path d="M2 6l3 3 5-5"/></svg></span><span>${routine.name}</span>`;
                list.appendChild(li);
            });
            updateRoutineButtonsState();
        }

        async function saveRoutine() {
            const name = await showModal({
                title: 'Save Routine',
                showInput: true,
                inputPlaceholder: 'Routine Name',
                confirmText: 'Save'
            });
            
            if (!name) return;

            const newRoutine = {
                name: name,
                exercises: JSON.parse(JSON.stringify(exercisesData)),
                workTime: getSecondsFromTimeInput('input-work'),
                restTime: getSecondsFromTimeInput('input-rest'),
                circuits: inputRounds.value,
                prepTime: getSecondsFromTimeInput('input-prepare'),
                coolDownTime: getSecondsFromTimeInput('input-cooldown'),
                voiceEnabled: voiceEnabled,
                audioType: audioType
            };

            savedRoutines.push(newRoutine);
            localStorage.setItem('intervalTimerRoutines', JSON.stringify(savedRoutines));
            updateRoutineSelect();
            
            // Select the new routine
            loadRoutine(savedRoutines.length - 1);
        }

        async function updateRoutine() {
            if (currentRoutineIndex === -1) return;
            
            const routine = savedRoutines[currentRoutineIndex];
            const confirmed = await showModal({
                title: 'Update Routine',
                message: `Update "${routine.name}" with current settings?`,
                confirmText: 'Update',
                confirmColor: 'bg-emerald-500'
            });
            
            if (!confirmed) return;

            const updatedRoutine = {
                name: routine.name,
                exercises: JSON.parse(JSON.stringify(exercisesData)),
                workTime: getSecondsFromTimeInput('input-work'),
                restTime: getSecondsFromTimeInput('input-rest'),
                circuits: inputRounds.value,
                prepTime: getSecondsFromTimeInput('input-prepare'),
                coolDownTime: getSecondsFromTimeInput('input-cooldown'),
                voiceEnabled: voiceEnabled,
                audioType: audioType
            };

            savedRoutines[currentRoutineIndex] = updatedRoutine;
            localStorage.setItem('intervalTimerRoutines', JSON.stringify(savedRoutines));
            
            // Visual feedback
            const btn = document.getElementById('btn-update-routine');
            const originalText = btn.innerText;
            btn.innerText = "Saved!";
            setTimeout(() => btn.innerText = originalText, 1500);
        }

        async function deleteRoutine() {
            if (currentRoutineIndex === -1) {
                await showModal({
                    title: 'No Routine Selected',
                    message: 'Please select a routine to delete.',
                    confirmText: 'OK',
                    cancelText: null,
                    confirmColor: 'bg-white/10'
                });
                return;
            }
            
            const confirmed = await showModal({
                title: 'Delete Routine',
                message: `Delete "${savedRoutines[currentRoutineIndex].name}"?`,
                confirmText: 'Delete',
                confirmColor: 'bg-red-500'
            });
            
            if (!confirmed) return;

            savedRoutines.splice(currentRoutineIndex, 1);
            localStorage.setItem('intervalTimerRoutines', JSON.stringify(savedRoutines));
            currentRoutineIndex = -1;
            document.getElementById('ac-ls-dropdown-title').textContent = "Select Routine";
            updateRoutineSelect();
            saveSettings();
        }

        async function renameRoutine() {
            if (currentRoutineIndex === -1) {
                await showModal({
                    title: 'No Routine Selected',
                    message: 'Please select a routine to rename.',
                    confirmText: 'OK',
                    cancelText: null,
                    confirmColor: 'bg-white/10'
                });
                return;
            }

            const routine = savedRoutines[currentRoutineIndex];
            const newName = await showModal({
                title: 'Rename Routine',
                showInput: true,
                inputValue: routine.name,
                inputPlaceholder: 'New Routine Name',
                confirmText: 'Rename'
            });

            if (!newName || newName.trim() === '' || newName.trim() === routine.name) return;

            savedRoutines[currentRoutineIndex].name = newName.trim();
            localStorage.setItem('intervalTimerRoutines', JSON.stringify(savedRoutines));
            document.getElementById('ac-ls-dropdown-title').textContent = newName.trim();
            updateRoutineSelect();
        }

        function exportRoutines() {
            if (savedRoutines.length === 0) {
                showModal({
                    title: 'No Routines',
                    message: 'You have no saved routines to export.',
                    confirmText: 'OK',
                    cancelText: null
                });
                return;
            }
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(savedRoutines, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "interval_timer_routines.json");
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        }

        function handleFileImport(input) {
            const file = input.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    const imported = JSON.parse(e.target.result);
                    if (Array.isArray(imported)) {
                        const confirmed = await showModal({
                            title: 'Import Routines',
                            message: `Found ${imported.length} routines. Import and append to your current list?`,
                            confirmText: 'Import',
                            confirmColor: 'bg-blue-500'
                        });

                        if (confirmed) {
                            savedRoutines = [...savedRoutines, ...imported];
                            localStorage.setItem('intervalTimerRoutines', JSON.stringify(savedRoutines));
                            updateRoutineSelect();
                            await showModal({
                                title: 'Success',
                                message: 'Routines imported successfully!',
                                confirmText: 'OK',
                                cancelText: null
                            });
                        }
                    }
                } catch (err) {
                    console.error(err);
                }
                input.value = ''; // Reset input
            };
            reader.readAsText(file);
        }

        function loadRoutine(index) {
            if (index === "" || index === -1) {
                return;
            }
            
            const routine = savedRoutines[index];
            if (!routine) return;
            
            currentRoutineIndex = parseInt(index);
            document.getElementById('ac-ls-dropdown-title').textContent = routine.name;
            updateRoutineSelect();
            
            // Apply settings
            exercisesData = JSON.parse(JSON.stringify(routine.exercises)); // Deep copy
            setTimeInputSeconds('input-work', routine.workTime);
            setTimeInputSeconds('input-rest', routine.restTime);
            setTimeInputSeconds('input-prepare', routine.prepTime);
            setTimeInputSeconds('input-cooldown', routine.coolDownTime || 0);
            inputRounds.value = routine.circuits;
            
            if (routine.voiceEnabled !== undefined) {
                voiceEnabled = routine.voiceEnabled;
                handleMuteToggle(voiceEnabled);
            }
            
            if (routine.audioType) {
                setAudioType(routine.audioType);
            }
            
            renderExerciseList();
            saveSettings(); // Save as current active settings
            updateTotalTimeDisplay();
            updateCountsDisplay();
            updateAllIntervalRowDims();
        }

        function updateRoutineButtonsState() {
            const updateBtn = document.getElementById('btn-update-routine');
            const renameBtn = document.getElementById('btn-rename-routine');
            const shouldBeEnabled = currentRoutineIndex !== -1;

            [updateBtn, renameBtn].forEach(btn => {
                if (!btn) return;
                btn.classList.toggle('opacity-50', !shouldBeEnabled);
                btn.classList.toggle('pointer-events-none', !shouldBeEnabled);
            });
        }

        function toggleDropdown(show) {
            const options = document.getElementById('ac-ls-dropdown-options');
            const button = document.getElementById('ac-ls-dropdown-select');
            const arrow = button.querySelector('svg');
            
            if (show === undefined) {
                show = options.classList.contains('hidden');
            }
            
            if (show) {
                options.classList.remove('hidden');
                button.setAttribute('aria-expanded', 'true');
                arrow.style.transform = 'rotate(180deg)';
            } else {
                options.classList.add('hidden');
                button.setAttribute('aria-expanded', 'false');
                arrow.style.transform = 'rotate(0deg)';
            }
        }

        // ============================================
        // CUSTOM MODAL MANAGER
        // ============================================
        function showModal({ title, message, showInput = false, inputValue = '', inputPlaceholder = '', confirmText = 'OK', confirmColor = 'bg-blue-500', cancelText = 'Cancel' }) {
            return new Promise((resolve) => {
                const modal = document.getElementById('custom-modal');
                const content = document.getElementById('modal-content');
                const titleEl = document.getElementById('modal-title');
                const msgEl = document.getElementById('modal-message');
                const inputEl = document.getElementById('modal-input');
                const confirmBtn = document.getElementById('modal-confirm');
                const cancelBtn = document.getElementById('modal-cancel');
                const btnContainer = document.getElementById('modal-buttons');

                titleEl.innerText = title;
                
                if (message) {
                    msgEl.innerText = message;
                    msgEl.classList.remove('hidden');
                } else {
                    msgEl.classList.add('hidden');
                }

                if (showInput) {
                    inputEl.value = inputValue;
                    inputEl.placeholder = inputPlaceholder;
                    inputEl.classList.remove('hidden');
                    setTimeout(() => inputEl.focus(), 50);
                } else {
                    inputEl.classList.add('hidden');
                }

                confirmBtn.innerText = confirmText;
                confirmBtn.className = `ios-button ${confirmColor} hover:opacity-90 text-white rounded-xl py-3 text-sm font-semibold transition-all`;
                
                if (!cancelText) {
                    cancelBtn.classList.add('hidden');
                    btnContainer.classList.remove('grid-cols-2');
                    btnContainer.classList.add('grid-cols-1');
                } else {
                    cancelBtn.innerText = cancelText;
                    cancelBtn.classList.remove('hidden');
                    btnContainer.classList.add('grid-cols-2');
                    btnContainer.classList.remove('grid-cols-1');
                }

                modal.classList.remove('hidden');
                requestAnimationFrame(() => {
                    modal.classList.remove('opacity-0');
                    content.classList.remove('scale-95');
                    content.classList.add('scale-100');
                });

                const close = (result) => {
                    modal.classList.add('opacity-0');
                    content.classList.remove('scale-100');
                    content.classList.add('scale-95');
                    setTimeout(() => {
                        modal.classList.add('hidden');
                        resolve(result);
                    }, 200);
                    
                    confirmBtn.onclick = null;
                    cancelBtn.onclick = null;
                    inputEl.onkeydown = null;
                };

                confirmBtn.onclick = () => close(showInput ? inputEl.value : true);
                cancelBtn.onclick = () => close(false);
                
                if (showInput) {
                    inputEl.onkeydown = (e) => {
                        if (e.key === 'Enter') close(inputEl.value);
                    };
                }
            });
        }

        function saveSettings() {
            const settings = {
                exercises: exercisesData,
                workTime: getSecondsFromTimeInput('input-work'),
                restTime: getSecondsFromTimeInput('input-rest'),
                circuits: inputRounds.value,
                prepTime: getSecondsFromTimeInput('input-prepare'),
                coolDownTime: getSecondsFromTimeInput('input-cooldown'),
                voiceEnabled: voiceEnabled,
                audioType: audioType,
                routineIndex: currentRoutineIndex
            };
            localStorage.setItem('intervalTimerSettings', JSON.stringify(settings));
        }

        function loadSettings() {
            const saved = localStorage.getItem('intervalTimerSettings');
            if (saved) {
                try {
                    const settings = JSON.parse(saved);
                    
                    // Handle legacy string format or new array format
                    if (settings.exercises) {
                        if (typeof settings.exercises === 'string') {
                            exercisesData = settings.exercises.split(',').filter(i => i.trim() !== "").map(item => {
                                const parts = item.split(':');
                                return { name: parts[0].trim(), duration: (parts[1] && !isNaN(parseInt(parts[1].trim()))) ? parseInt(parts[1].trim()) : null };
                            });
                        } else if (Array.isArray(settings.exercises)) {
                            exercisesData = settings.exercises;
                        }
                    }
                    
                    // Load time values
                    if (settings.workTime !== undefined) {
                        setTimeInputSeconds('input-work', settings.workTime);
                    }
                    if (settings.restTime !== undefined) {
                        setTimeInputSeconds('input-rest', settings.restTime);
                    }
                    if (settings.prepTime !== undefined) {
                        setTimeInputSeconds('input-prepare', settings.prepTime);
                    }
                    if (settings.coolDownTime !== undefined) {
                        setTimeInputSeconds('input-cooldown', settings.coolDownTime);
                    }
                    
                    inputRounds.value = settings.circuits || inputRounds.value;
                    voiceEnabled = settings.voiceEnabled !== undefined ? settings.voiceEnabled : true;
                    handleMuteToggle(voiceEnabled);
                    
                    // Load audio type
                    audioType = settings.audioType || 'voice';
                    
                    // Load selected routine index
                    if (settings.routineIndex !== undefined) {
                        if (settings.routineIndex !== -1 && savedRoutines[settings.routineIndex]) {
                            currentRoutineIndex = settings.routineIndex;
                            document.getElementById('ac-ls-dropdown-title').textContent = savedRoutines[currentRoutineIndex].name;
                        } else {
                            currentRoutineIndex = -1;
                        }
                        updateRoutineButtonsState();
                    }

                    updateAudioTypeUI();
                    renderExerciseList();
                } catch (e) {
                    console.error('Error loading settings:', e);
                }
            }
        }
        
        function setAudioType(type) {
            audioType = type;
            updateAudioTypeUI();
            saveSettings();
        }
        
        function updateAudioTypeUI() {
            const voiceCheck = document.getElementById('audio-voice-check');
            const beepCheck  = document.getElementById('audio-beep-check');
            const voiceBtn   = document.getElementById('btn-audio-voice');
            const beepBtn    = document.getElementById('btn-audio-beep');
            if (!voiceCheck || !beepCheck) return;

            if (audioType === 'voice') {
                voiceCheck.classList.remove('hidden');
                beepCheck.classList.add('hidden');
                voiceBtn.style.backgroundColor = 'rgba(255,255,255,0.06)';
                beepBtn.style.backgroundColor = '';
            } else {
                beepCheck.classList.remove('hidden');
                voiceCheck.classList.add('hidden');
                beepBtn.style.backgroundColor = 'rgba(255,255,255,0.06)';
                voiceBtn.style.backgroundColor = '';
            }
        }

        // Dim an interval row when its value is zero (phase is effectively disabled)
        function updateIntervalRowDim(inputId) {
            const rowMap = {
                'input-prepare':  'row-prepare',
                'input-cooldown': 'row-cooldown',
                'input-rest':     'row-rest',
                'input-work':     'row-work',
            };
            const rowId = rowMap[inputId];
            if (!rowId) return;
            const row = document.getElementById(rowId);
            if (!row) return;
            const secs = parseFloat(document.getElementById(inputId)?.dataset?.seconds || 0);
            row.classList.toggle('is-zero', secs === 0);
        }

        // Run dim check on all interval rows on page load / routine load
        function updateAllIntervalRowDims() {
            ['input-prepare', 'input-cooldown', 'input-rest', 'input-work'].forEach(updateIntervalRowDim);
        }

        function showSettingsSaved() {
            const box = document.getElementById('message-box');
            if (!box) return;
            box.textContent = 'Settings saved';
            box.style.opacity = '1';
            clearTimeout(box._hideTimer);
            box._hideTimer = setTimeout(() => { box.style.opacity = '0'; }, 1500);
        }

        function setupAutoSave() {
            [inputWork, inputRest, inputRounds, inputPrepare, document.getElementById('input-cooldown')].forEach(el => {
                el.addEventListener('input', () => {
                    saveSettings();
                    updateTotalTimeDisplay();
                    updateCountsDisplay();
                    updateIntervalRowDim(el.id);
                });
                
                el.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.target.blur();
                    }
                });
            });
        }

        // ============================================
        // EXERCISE LIST UI HANDLERS
        // ============================================
        function renderExerciseList() {
            const container = document.getElementById('exercises-list');
            if (!container) return;
            container.innerHTML = '';
            
            exercisesData.forEach(item => {
                createExerciseRow(item.name, item.duration || '');
            });
            
            if (exercisesData.length === 0) createExerciseRow('', '');
        }

        function createExerciseRow(name = '', duration = '') {
            const container = document.getElementById('exercises-list');
            const div = document.createElement('div');
            
            // Format duration if it exists
            const formattedDuration = (duration !== '' && duration !== null) ? formatToMMSS(duration) : '';
            
            // Add transition classes for entry animation
            div.className = 'exercise-row relative overflow-hidden rounded-xl transition-all duration-300 ease-out opacity-0 translate-y-2 max-h-0 select-none';
            div.innerHTML = `
                <div class="row-content w-full flex items-center bg-white/5 py-3 px-4">
                    <input type="text" value="${name}" placeholder="Exercise Name" class="exercise-name-input flex-1 min-w-0 bg-transparent border-none p-0 text-sm font-medium focus:ring-0 outline-none placeholder:text-white/20 text-white">
                    
                    <input type="text" value="${formattedDuration}" placeholder="--:--" onclick="this.select()" class="exercise-duration-input w-16 bg-transparent border-none p-0 text-sm text-right focus:ring-0 outline-none placeholder:text-white/20 text-white tabular-nums font-bold mx-3">

                    <button onclick="removeExerciseRow(this)" class="delete-btn ios-button w-8 h-8 flex-shrink-0 flex items-center justify-center rounded-full bg-white/5 text-white/30 hover:bg-white/10 hover:text-white transition-all ml-1">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
                    </button>
                </div>
            `;
            container.appendChild(div);
            
            // Trigger animation
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    div.classList.remove('opacity-0', 'translate-y-2', 'max-h-0');
                    div.classList.add('max-h-20');
                });
            });
            
            setupLongPressDrag(div);
            
            const inputs = div.querySelectorAll('input');
            inputs.forEach(input => {
                input.addEventListener('input', updateExercisesFromUI);
                
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.target.blur();
                    }
                });
                
                // Add blur handler for time formatting
                if (input.classList.contains('exercise-duration-input')) {
                    input.addEventListener('blur', function() {
                        const val = this.value.trim();
                        if (val) {
                            const seconds = parseTimeInput(val);
                            this.value = seconds > 0 ? formatToMMSS(seconds) : '';
                        }
                        updateExercisesFromUI();
                    });
                }
            });
        }

        function addNewExerciseRow() {
            createExerciseRow('', '');
            updateExercisesFromUI();
        }

        function removeExerciseRow(btn) {
            const row = btn.closest('.exercise-row');
            
            // Set explicit height for transition
            row.style.maxHeight = row.scrollHeight + 'px';
            row.classList.add('overflow-hidden');
            void row.offsetWidth; // Force reflow

            // Exit animation
            row.style.maxHeight = '0px';
            row.classList.add('opacity-0', '-translate-y-2', '!mt-0', '!mb-0', 'pointer-events-none');
            
            setTimeout(() => {
                row.remove();
                updateExercisesFromUI();
                
                // Ensure we don't leave an empty list
                if (document.getElementById('exercises-list').children.length === 0) {
                    addNewExerciseRow();
                }
            }, 300);
        }

        // ============================================
        // DRAG AND DROP REORDERING
        // ============================================
        let draggingRow = null;
        let ghost = null;
        let dragOffsetY = 0;
        let dragFrameId = null;

        function setupLongPressDrag(element) {
            let timer = null;
            let startX = 0;
            let startY = 0;

            const handleStart = (e) => {
                if (e.target.closest('.delete-btn')) return;
                
                const isInput = e.target.tagName === 'INPUT';
                const isTouch = e.type.startsWith('touch');
                
                // If mouse and not input, drag immediately
                if (!isTouch && !isInput) {
                     const clientX = e.clientX;
                     const clientY = e.clientY;
                     startDrag(element, clientX, clientY, e);
                     e.preventDefault(); 
                     return;
                }
                
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                
                startX = clientX;
                startY = clientY;

                timer = setTimeout(() => {
                    startDrag(element, startX, startY, e);
                }, 300);
            };

            const handleMove = (e) => {
                if (!timer) return;
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                
                if (Math.abs(clientX - startX) > 10 || Math.abs(clientY - startY) > 10) {
                    clearTimeout(timer);
                    timer = null;
                }
            };

            const handleEnd = () => {
                if (timer) {
                    clearTimeout(timer);
                    timer = null;
                }
            };

            element.addEventListener('touchstart', handleStart, {passive: true});
            element.addEventListener('touchmove', handleMove, {passive: true});
            element.addEventListener('touchend', handleEnd);
            
            element.addEventListener('mousedown', handleStart);
            element.addEventListener('mousemove', handleMove);
            element.addEventListener('mouseup', handleEnd);
            element.addEventListener('mouseleave', handleEnd);
        }

        function startDrag(row, clientX, clientY, originalEvent) {
            draggingRow = row;
            
            const rect = row.getBoundingClientRect();
            dragOffsetY = clientY - rect.top;
            
            // Create Ghost
            ghost = row.cloneNode(true);
            ghost.classList.add('ghost');
            ghost.style.width = rect.width + 'px';
            ghost.style.height = rect.height + 'px';
            ghost.style.top = rect.top + 'px';
            ghost.style.left = rect.left + 'px';
            
            // Disable inputs in ghost
            ghost.querySelectorAll('input').forEach(i => i.setAttribute('disabled', 'true'));
            
            document.body.appendChild(ghost);
            
            row.classList.add('placeholder');
            
            // Vibration
            if (navigator.vibrate) navigator.vibrate(50);
            
            document.body.style.overflow = 'hidden';
            
            if (originalEvent.type.startsWith('touch')) {
                document.addEventListener('touchmove', onDragMove, {passive: false});
                document.addEventListener('touchend', onDragEnd);
            } else {
                document.addEventListener('mousemove', onDragMove);
                document.addEventListener('mouseup', onDragEnd);
            }
        }

        function onDragMove(e) {
            if (!draggingRow || !ghost) return;
            if (e.type === 'touchmove') e.preventDefault();
            
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            
            // Move Ghost
            // Move Ghost immediately for responsiveness
            ghost.style.top = (clientY - dragOffsetY) + 'px';
            
            // Throttle heavy layout calculations
            if (dragFrameId) return;
            
            dragFrameId = requestAnimationFrame(() => {
                handleDragReorder(clientX, clientY);
                dragFrameId = null;
            });
        }

        function handleDragReorder(clientX, clientY) {
            const elementBelow = document.elementFromPoint(clientX, clientY);
            if (!elementBelow) return;
            
            const rowBelow = elementBelow.closest('.exercise-row');
            
            if (rowBelow && rowBelow !== draggingRow) {
                const container = document.getElementById('exercises-list');
                const rows = Array.from(container.children);
                
                const draggingIndex = rows.indexOf(draggingRow);
                const targetIndex = rows.indexOf(rowBelow);
                
                // Calculate threshold to prevent flickering
                const targetRect = rowBelow.getBoundingClientRect();
                const targetMiddleY = targetRect.top + targetRect.height / 2;
                const isMovingDown = draggingIndex < targetIndex;
                
                // Only swap if we have crossed the midline of the target element
                if (isMovingDown && clientY < targetMiddleY) return;
                if (!isMovingDown && clientY > targetMiddleY) return;

                // FLIP Animation: Capture old positions
                const positions = new Map();
                rows.forEach(r => positions.set(r, r.getBoundingClientRect().top));

                if (isMovingDown) {
                    container.insertBefore(draggingRow, rowBelow.nextSibling);
                } else {
                    container.insertBefore(draggingRow, rowBelow);
                }
                
                // FLIP Animation: Play
                rows.forEach(r => {
                    if (r === draggingRow) return; // Don't animate placeholder
                    const oldTop = positions.get(r);
                    const newTop = r.getBoundingClientRect().top;
                    
                    if (oldTop && newTop && oldTop !== newTop) {
                        const delta = oldTop - newTop;
                        r.style.transition = 'none';
                        r.style.transform = `translateY(${delta}px)`;
                        
                        requestAnimationFrame(() => {
                            r.style.transition = 'transform 0.3s ease';
                            r.style.transform = '';
                        });
                    }
                });
            }
        }

        function onDragEnd(e) {
            if (draggingRow && ghost) {
                // Animate ghost to final position
                const rect = draggingRow.getBoundingClientRect();
                ghost.style.transition = 'top 0.2s ease, left 0.2s ease';
                ghost.style.top = rect.top + 'px';
                ghost.style.left = rect.left + 'px';
                
                setTimeout(() => {
                    if (ghost) ghost.remove();
                    if (draggingRow) draggingRow.classList.remove('placeholder');
                    ghost = null;
                    draggingRow = null;
                    updateExercisesFromUI();
                }, 200);
            } else {
                draggingRow = null;
            }
            
            document.body.style.overflow = '';
            
            document.removeEventListener('touchmove', onDragMove);
            document.removeEventListener('touchend', onDragEnd);
            document.removeEventListener('mousemove', onDragMove);
            document.removeEventListener('mouseup', onDragEnd);
            
            if (dragFrameId) {
                cancelAnimationFrame(dragFrameId);
                dragFrameId = null;
            }
        }

        function updateExercisesFromUI() {
            const container = document.getElementById('exercises-list');
            const rows = container.querySelectorAll('.exercise-row');
            const newExercises = [];
            
            rows.forEach(row => {
                const nameInput = row.querySelector('.exercise-name-input');
                const durInput = row.querySelector('.exercise-duration-input');
                let name = nameInput.value.trim();
                let durationVal = durInput.value.trim();
                
                // Allow empty names so the row isn't lost in data model
                newExercises.push({ name: name, duration: durationVal ? parseTimeInput(durationVal) : null });
            });
            
            exercisesData = newExercises;
            
            saveSettings();
            updateTotalTimeDisplay();
            updateCountsDisplay();
        }

        // ============================================
        // TIME INPUT HELPERS (MM:SS format)
        // ============================================
        function parseTimeInput(value) {
            // Remove any spaces
            value = value.trim();
            
            // If contains colon, parse as MM:SS
            if (value.includes(':')) {
                const parts = value.split(':');
                const min = parseInt(parts[0]) || 0;
                const sec = parseInt(parts[1]) || 0;
                return min * 60 + sec;
            }
            
            // Otherwise treat as seconds
            return parseInt(value) || 0;
        }

        function formatToMMSS(seconds) {
            seconds = Math.max(0, seconds); // No negatives
            const min = Math.floor(seconds / 60);
            const sec = seconds % 60;
            return `${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;
        }

        function handleTimeBlur(inputId) {
            const input = document.getElementById(inputId);
            const seconds = parseTimeInput(input.value);
            input.setAttribute('data-seconds', seconds);
            input.value = formatToMMSS(seconds);
            
            // Trigger save and update
            saveSettings();
            updateTotalTimeDisplay();
        }

        function getSecondsFromTimeInput(inputId) {
            const input = document.getElementById(inputId);
            return parseInt(input.getAttribute('data-seconds')) || 0;
        }

        function setTimeInputSeconds(inputId, seconds) {
            const input = document.getElementById(inputId);
            seconds = Math.max(0, seconds);
            input.setAttribute('data-seconds', seconds);
            input.value = formatToMMSS(seconds);
            
            // Trigger save and update
            input.dispatchEvent(new Event('input'));
        }

        // ============================================
        // INCREMENT/DECREMENT WITH LONG-PRESS (for time inputs)
        // ============================================
        let adjustmentInterval = null;
        let adjustmentTimeout = null;
        let speedUpTimeout = null;
        let isAdjusting = false; // Prevent double-fire on mobile
        
        // New state variables for scroll vs. tap detection
        let tapTimeout = null;
        let isScrolling = false;
        let touchStartY = 0;

        function incrementTimeValue(inputId) { // +5 seconds
            const seconds = getSecondsFromTimeInput(inputId);
            setTimeInputSeconds(inputId, seconds + 5);
            
            // Haptic feedback on mobile
            if (navigator.vibrate) {
                navigator.vibrate(10);
            }
        }

        function decrementTimeValue(inputId) { // -5 seconds
            const seconds = getSecondsFromTimeInput(inputId);
            setTimeInputSeconds(inputId, seconds - 5);
            
            // Haptic feedback on mobile
            if (navigator.vibrate) {
                navigator.vibrate(10);
            }
        }

        function startAdjustment(actionFn) {
            // Don't start a new adjustment if one is in progress or if we are scrolling
            if (isAdjusting || isScrolling) return;
            isAdjusting = true;

            const performActionAndHold = () => {
                actionFn(); // Perform the first action

                // Set up the long-press timer to repeat the action
                adjustmentTimeout = setTimeout(() => {
                    adjustmentInterval = setInterval(actionFn, 150); // Repeat every 150ms
                    
                    // Speed up after 2 seconds
                    speedUpTimeout = setTimeout(() => {
                        clearInterval(adjustmentInterval);
                        adjustmentInterval = setInterval(actionFn, 75); // Repeat faster
                    }, 2000);
                }, 420); // Wait 420ms after the first action to start repeating (total ~500ms)
            };

            // Set a short timeout. If it's not cleared by a scroll, we consider it a tap/hold.
            tapTimeout = setTimeout(performActionAndHold, 80);
        }

        function startTimeIncrement(inputId, event) {
            startAdjustment(() => incrementTimeValue(inputId));
        }

        function startTimeDecrement(inputId, event) {
            startAdjustment(() => decrementTimeValue(inputId));
        }

        function stopAdjustment() {
            clearTimeout(adjustmentTimeout);
            clearTimeout(speedUpTimeout);
            clearInterval(adjustmentInterval);
            isAdjusting = false;
        }

        function cancelAllAdjustments() {
            clearTimeout(tapTimeout);
            tapTimeout = null;
            stopAdjustment();
        }

        // ============================================
        // CIRCUITS INCREMENT/DECREMENT (still uses +/- 1)
        // ============================================
        function incrementValue(inputId) {
            const input = document.getElementById(inputId);
            const currentValue = parseInt(input.value) || 0;
            const min = parseInt(input.min) || 0;
            const max = parseInt(input.max) || 999;
            
            if (currentValue < max) {
                input.value = currentValue + 1;
                input.dispatchEvent(new Event('input'));
                
                if (navigator.vibrate) {
                    navigator.vibrate(10);
                }
            }
        }

        function decrementValue(inputId) {
            const input = document.getElementById(inputId);
            const currentValue = parseInt(input.value) || 0;
            const min = parseInt(input.min) || 0;
            
            if (currentValue > min) {
                input.value = currentValue - 1;
                input.dispatchEvent(new Event('input'));
                
                if (navigator.vibrate) {
                    navigator.vibrate(10);
                }
            }
        }

        function startIncrement(inputId) {
            startAdjustment(() => incrementValue(inputId));
        }

        function startDecrement(inputId) {
            startAdjustment(() => decrementValue(inputId));
        }


        function switchTab(tab) {
            const timerView = document.getElementById('view-timer');
            const settingsView = document.getElementById('view-settings');

            if (tab === 'timer') {
                settingsView.classList.remove('active');
                timerView.classList.add('active');
                updateTotalTimeDisplay();
            } else {
                timerView.classList.remove('active');
                settingsView.classList.add('active');
                if (timer && !isPaused) togglePause();
            }
        }

        function toggleMute() { 
            voiceEnabled = !voiceEnabled; 
            handleMuteToggle(voiceEnabled);
            saveSettings();
        }
        
        function handleMuteToggle(isUnmuted) {
            if (isUnmuted) { 
                btnMute.classList.remove('is-muted'); 
                iconMuted.classList.add('hidden'); 
                iconUnmuted.classList.remove('hidden'); 
            } else { 
                btnMute.classList.add('is-muted'); 
                iconMuted.classList.remove('hidden'); 
                iconUnmuted.classList.add('hidden'); 
                speechManager.cancel();
            }
        }
        
        // speak() is ONLY for voice TTS. Beep sounds are triggered directly
        // via beep() at each phase transition and countdown tick.
        function speak(text) {
            if (!voiceEnabled) return;
            if (audioType === 'beep') return;
            speechManager.speak(text, voiceEnabled);
        }

        // beep() is ONLY for beep mode. Called directly at phase transitions and countdown.
        function beep(type) {
            if (!voiceEnabled) return;
            if (audioType !== 'beep') return;
            switch (type) {
                case 'prepare':   soundManager.playPrepare();   break;
                case 'work':      soundManager.playWorkStart(); break;
                case 'rest':      soundManager.playRestStart(); break;
                case 'cooldown':  soundManager.playRestStart(); break;
                case 'countdown': soundManager.playCountdown(); break;
                case 'complete':  soundManager.playComplete();  break;
            }
        }
        
        function updateProgress(percent) { 
            // Direct update for smooth animation via requestAnimationFrame
            progressCircle.style.strokeDashoffset = CIRCUMFERENCE - (percent / 100 * CIRCUMFERENCE);
        }

        function refillProgress() {
            // Temporarily enable transition for smooth refill
            progressCircle.style.transition = 'stroke-dashoffset 0.05s ease-out, stroke 0.4s ease';
            
            // Set to full
            progressCircle.style.strokeDashoffset = '0';
            
            // Remove transition after animation
            setTimeout(() => {
                progressCircle.style.transition = 'stroke 0.4s ease';
            }, 50);
        }

        function formatTime(seconds) { return `${Math.floor(seconds / 60).toString().padStart(2, '0')}:${(seconds % 60).toString().padStart(2, '0')}`; }
        function parseExercises() { 
            const defaultWork = getSecondsFromTimeInput('input-work'); 
            return exercisesData.map((item, index) => { 
                return { 
                    name: item.name || `Exercise ${index + 1}`, 
                    duration: item.duration || defaultWork 
                }; 
            }); 
        }
        
        function calculateTotalTime() {
            const exercises = parseExercises();
            if (exercises.length === 0) return 0;
            
            const circuits = parseInt(inputRounds.value);
            const restTime = getSecondsFromTimeInput('input-rest');
            const prepTime = getSecondsFromTimeInput('input-prepare');
            const coolDownTime = getSecondsFromTimeInput('input-cooldown');
            
            let totalWorkTime = 0;
            exercises.forEach(ex => {
                totalWorkTime += ex.duration;
            });
            
            const totalTime = prepTime + (totalWorkTime * circuits) + (restTime * (exercises.length * circuits - 1)) + coolDownTime;
            
            return totalTime;
        }
        
        function updateProgressBar(time, isRunning) {
            if (!totalProgressBar) return;

            let progress;
            if (isRunning) {
                // Smoothly update based on precise time remaining
                progress = (initialTotalTime > 0) ? (time / initialTotalTime) * 100 : 0;
            } else {
                // Set static state: 100% if a workout is configured, 0% otherwise
                progress = (time > 0) ? 100 : 0;
            }
            totalProgressBar.style.width = `${Math.max(0, Math.min(100, progress))}%`;
        }

        function updateTotalTimeDisplay(secondsOverride = null) {
            // If a specific time is provided (during workout), use it. 
            // Otherwise calculate from settings (during setup).
            const totalSeconds = secondsOverride !== null ? secondsOverride : calculateTotalTime();
            
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            totalTimeDisplayEl.innerText = `Total: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            // Hide total time if 0 and not currently running a workout (setup mode)
            if (secondsOverride === null && totalSeconds === 0) {
                totalTimeDisplayEl.classList.add('opacity-0');
                if (totalProgressBarContainer) totalProgressBarContainer.classList.add('opacity-0');
            } else {
                totalTimeDisplayEl.classList.remove('opacity-0');
                if (totalProgressBarContainer) totalProgressBarContainer.classList.remove('opacity-0');
            }

            // Update Total Progress Bar only when timer is NOT running.
            // When timer is running, it's handled by updateProgressBarOnly on each frame.
            if (!timer && !isPaused) { updateProgressBar(totalSeconds, false); }
        }
        
        function updateCountsDisplay() {
            const exercises = parseExercises();
            const totalCircuits = parseInt(inputRounds.value) || 1;
            const count = exercises.length || 0;
            
            // Always show the counts based on current settings
            if (count > 0) {
                roundDisplayEl.innerText = `Exercise 1 / ${count}`;
                circuitDisplayEl.innerText = `Circuit 1 / ${totalCircuits}`;
            } else {
                roundDisplayEl.innerText = 'Add Exercises';
                circuitDisplayEl.innerText = ' ';
            }
            
            // Show first exercise as "Next" when stopped
            if (!timer && !isPaused) {
                if (count > 0) {
                    nextExerciseNameEl.innerText = exercises[0].name;
                    nextUpContainer.classList.remove('opacity-0');
                    nextUpContainer.classList.add('opacity-100');
                } else {
                    nextUpContainer.classList.remove('opacity-100');
                    nextUpContainer.classList.add('opacity-0');
                }
            }
        }
        
        function getIntervalData(index) { 
            const listSize = exerciseObjects.length; 
            if (listSize === 0) return null; 
            return { 
                exercise: exerciseObjects[index % listSize], 
                exerciseNum: (index % listSize) + 1, 
                circuitNum: Math.floor(index / listSize) + 1, 
                isLastOverall: (index === (listSize * parseInt(inputRounds.value)) - 1) 
            }; 
        }

        const phaseStyles = {
            prepare: { circle: 'text-blue-500', text: 'text-blue-400', bar: 'bg-blue-500', shadow: 'shadow-[0_0_10px_rgba(59,130,246,0.5)]' },
            work:    { circle: 'text-emerald-500', text: 'text-emerald-400', bar: 'bg-emerald-500', shadow: 'shadow-[0_0_10px_rgba(16,185,129,0.5)]' },
            rest:    { circle: 'text-orange-500', text: 'text-orange-400', bar: 'bg-orange-500', shadow: 'shadow-[0_0_10px_rgba(245,158,11,0.5)]' },
            cooldown:{ circle: 'text-teal-500', text: 'text-teal-400', bar: 'bg-teal-500', shadow: 'shadow-[0_0_10px_rgba(20,184,166,0.5)]' },
        };
        const allCircleClasses = Object.values(phaseStyles).map(s => s.circle);
        const allTextClasses = Object.values(phaseStyles).map(s => s.text);
        const allBarClasses = Object.values(phaseStyles).map(s => s.bar);
        const allShadowClasses = Object.values(phaseStyles).map(s => s.shadow);

        function setVisualState(phase, instant = false) {
            if (instant) { progressCircle.style.transition = 'none'; }

            const style = phaseStyles[phase];
            if (style) {
                progressCircle.classList.remove(...allCircleClasses, 'text-yellow-300', 'text-yellow-400');
                progressCircle.classList.add(style.circle);
                
                exerciseTextEl.classList.remove(...allTextClasses, 'text-yellow-300', 'text-yellow-400');
                exerciseTextEl.classList.add(style.text);

                totalProgressBar.classList.remove(...allBarClasses, ...allShadowClasses, 'bg-yellow-300', 'shadow-[0_0_10px_rgba(253,224,71,0.5)]');
                totalProgressBar.classList.add(style.bar, style.shadow);
            }

            if (phase === 'prepare') {
                exerciseTextEl.innerText = "Get Ready";
                const info = getIntervalData(0);
                roundDisplayEl.innerText = `Exercise ${info.exerciseNum} / ${exerciseObjects.length}`;
                circuitDisplayEl.innerText = `Circuit ${info.circuitNum} / ${inputRounds.value}`;
                nextExerciseNameEl.innerText = info.exercise.name;
                nextUpContainer.classList.replace('opacity-0', 'opacity-100');
                beep('prepare');
                speak(`Get ready. First, ${info.exercise.name}.`);
            } else if (phase === 'rest') {
                exerciseTextEl.innerText = "Rest";
                const info = getIntervalData(globalIntervalIndex + 1);
                nextExerciseNameEl.innerText = info.exercise.name;
                nextUpContainer.classList.replace('opacity-0', 'opacity-100');
                beep('rest');
                speak(`Rest. Next is ${info.exercise.name}.`);
            } else if (phase === 'cooldown') {
                exerciseTextEl.innerText = "Cool Down";
                roundDisplayEl.innerText = "Cool Down";
                nextExerciseNameEl.innerText = "Complete";
                nextUpContainer.classList.replace('opacity-0', 'opacity-100');
                beep('cooldown');
                speak("Cool Down");
            } else {
                const info = getIntervalData(globalIntervalIndex);
                exerciseTextEl.innerText = info.exercise.name;
                roundDisplayEl.innerText = `Exercise ${info.exerciseNum} / ${exerciseObjects.length}`;
                circuitDisplayEl.innerText = `Circuit ${info.circuitNum} / ${inputRounds.value}`;
                
                if (!info.isLastOverall) {
                    nextExerciseNameEl.innerText = "Rest";
                    nextUpContainer.classList.replace('opacity-0', 'opacity-100');
                } else {
                    nextUpContainer.classList.replace('opacity-100', 'opacity-0');
                }
                beep('work');
                speak(info.exercise.name + ". Begin.");
            }

            if (instant) { progressCircle.style.transition = ''; }
        }

        function runTimerLoop() {
            if (isPaused) return;
            
            timer = requestAnimationFrame(runTimerLoop);
            
            const now = Date.now();
            const timeLeftMs = phaseEndTime - now;
            
            if (timeLeftMs <= 0) {
                cancelAnimationFrame(timer);
                nextPhase();
                return;
            }

            // Smooth progress update
            const percent = (timeLeftMs / (totalPhaseSeconds * 1000)) * 100;
            updateProgress(percent);

            // Integer second updates for text display
            const currentSeconds = Math.ceil(timeLeftMs / 1000);
            if (currentSeconds !== secondsRemaining) {
                secondsRemaining = currentSeconds;
                timeLeftEl.innerText = formatTime(secondsRemaining);
                
                if (totalTimeRemaining > 0) totalTimeRemaining--;
                updateTotalTimeDisplay(totalTimeRemaining); // Update text and non-timer bar state
                
                if (secondsRemaining <= 3 && secondsRemaining > 0) {
                    beep('countdown');
                    speak(secondsRemaining.toString());
                }
            }
            const preciseTotalTime = workoutEndTime > 0 ? (workoutEndTime - Date.now()) / 1000 : 0;
            updateProgressBar(preciseTotalTime, true);
        }

        function nextPhase(isManualSkip = false) {
            if (!timer) return;
            // If manually skipping, cancel current loop frame to prevent double-fire
            if (timer) cancelAnimationFrame(timer);
            
            // If this is a natural transition (not a manual skip), the last second just ended.
            // We need to decrement the total time to account for it before starting the next phase.
            if (!isManualSkip && totalTimeRemaining > 0) {
                totalTimeRemaining--;
            }

            // If skipping manually, deduct precise time left in current phase
            if (isManualSkip) {
                let timeToSkip = 0;
                if (isPaused) {
                    timeToSkip = pausedTimeRemainingMs;
                } else {
                    timeToSkip = Math.max(0, phaseEndTime - Date.now());
                }

                if (timeToSkip > 0) {
                    workoutEndTime -= timeToSkip;
                    
                    // Update integer display
                    const skippedSeconds = Math.ceil(timeToSkip / 1000);
                    totalTimeRemaining = Math.max(0, totalTimeRemaining - skippedSeconds);
                    updateTotalTimeDisplay(totalTimeRemaining);

                    // Force update progress bar immediately
                    const preciseTotalTime = Math.max(0, (workoutEndTime - Date.now()) / 1000);
                    updateProgressBar(preciseTotalTime, true);
                }
            }
            
            if (currentPhase === 'prepare') { currentPhase = 'work'; globalIntervalIndex = 0; totalPhaseSeconds = getIntervalData(0).exercise.duration; }
            else if (currentPhase === 'work') { 
                if (getIntervalData(globalIntervalIndex).isLastOverall) { 
                    const coolDown = getSecondsFromTimeInput('input-cooldown');
                    if (coolDown > 0) {
                        currentPhase = 'cooldown';
                        totalPhaseSeconds = coolDown;
                    } else {
                        completeWorkout(); return; 
                    }
                } else { currentPhase = 'rest'; totalPhaseSeconds = getSecondsFromTimeInput('input-rest'); }
            }
            else if (currentPhase === 'cooldown') { completeWorkout(); return; }
            else { globalIntervalIndex++; currentPhase = 'work'; totalPhaseSeconds = getIntervalData(globalIntervalIndex).exercise.duration; } // Rest -> Work
            secondsRemaining = totalPhaseSeconds;
            
            setVisualState(currentPhase, isManualSkip);
            timeLeftEl.innerText = formatTime(secondsRemaining);
            refillProgress();
            
            if (!isPaused) {
                phaseEndTime = Date.now() + (totalPhaseSeconds * 1000);
                runTimerLoop();
            } else {
                // If paused, prepare the time for when we eventually resume
                pausedTimeRemainingMs = totalPhaseSeconds * 1000;
            }
        }

        async function startWorkout() {
            exerciseObjects = parseExercises();
            if (exerciseObjects.length === 0) {
                // If no exercises, add one so the user can start
                addNewExerciseRow();
                return;
            }
            
            // Clean up any completion animations from previous workout
            exerciseTextEl.classList.remove('pulse-text', 'text-yellow-300', 'text-yellow-400');
            progressCircle.classList.remove('pulse-circle-stroke', 'text-yellow-300', 'text-yellow-400');
            
            // Remove completion glow if it exists
            const completionGlow = document.getElementById('completion-glow');
            if (completionGlow) completionGlow.remove();
            
            await wakeLockManager.enable();
            
            const prep = getSecondsFromTimeInput('input-prepare');
            isPaused = false;
            currentPhase = prep > 0 ? 'prepare' : 'work';
            totalPhaseSeconds = prep > 0 ? prep : getIntervalData(0).exercise.duration;
            secondsRemaining = totalPhaseSeconds;
            phaseEndTime = Date.now() + (totalPhaseSeconds * 1000);
            totalTimeRemaining = calculateTotalTime(); // Initialize total countdown
            initialTotalTime = totalTimeRemaining; // Store initial total for progress bar
            workoutEndTime = Date.now() + (initialTotalTime * 1000);
            
            timeLeftEl.innerText = formatTime(secondsRemaining); 
            updateProgress(100); // Set initial progress to full
            
            setVisualState(currentPhase);
            btnStart.classList.add('hidden');
            btnPause.classList.remove('hidden');
            
            // Start timer AFTER displaying initial state
            if (timer) cancelAnimationFrame(timer);
            runTimerLoop();
            switchTab('timer');
        }

        async function togglePause() { 
            if (!timer) return; 
            isPaused = !isPaused; 
            
            if (isPaused) {
                cancelAnimationFrame(timer);
                // Calculate exact remaining time to preserve precision
                pausedTimeRemainingMs = phaseEndTime - Date.now();
                pauseStartTime = Date.now();
                
                await wakeLockManager.disable();
                speechManager.cancel();
                btnStart.innerText = "Resume";
            } else {
                // Resume using exact stored time
                phaseEndTime = Date.now() + pausedTimeRemainingMs;
                if (pauseStartTime > 0) {
                    const pauseDuration = Date.now() - pauseStartTime;
                    workoutEndTime += pauseDuration;
                    pauseStartTime = 0;
                }
                await wakeLockManager.enable();
                runTimerLoop();
            }
            
            btnStart.classList.toggle('hidden', !isPaused); 
            btnPause.classList.toggle('hidden', isPaused); 
        }
        
        async function completeWorkout() { 
            if (timer) cancelAnimationFrame(timer);
            timer = null; 
            
            await wakeLockManager.disable();

            // Set final time to 00:00
            totalTimeRemaining = 0;
            updateTotalTimeDisplay(totalTimeRemaining);
            
            // Visual celebration - synchronized pulsing
            
            // Change text to soft pastel yellow
            exerciseTextEl.innerText = "Amazing!"; 
            exerciseTextEl.classList.remove(...allTextClasses);
            exerciseTextEl.classList.add('text-yellow-300');
            
            // Add pulsing to text
            exerciseTextEl.classList.add('pulse-text');
            
            // Make the circle full (100%) so entire circle glows
            refillProgress();
            
            // Make progress circle pulse
            progressCircle.classList.add('pulse-circle-stroke');
            
            // Add circular radial glow behind the circle - soft pastel yellow
            const progressContainer = document.querySelector('.progress-svg-container');
            const glowDiv = document.createElement('div');
            glowDiv.className = 'pulse-radial-glow';
            glowDiv.id = 'completion-glow';
            progressContainer.insertBefore(glowDiv, progressContainer.firstChild);
            
            // Vibration feedback (if supported)
            if (navigator.vibrate) {
                navigator.vibrate([200, 100, 200, 100, 200]);
            }
            
            // Make progress circle soft yellow for completion
            progressCircle.classList.remove(...allCircleClasses, 'text-yellow-400');
            progressCircle.classList.add('text-yellow-300');

            // Make total progress bar yellow and full to signify 100% completion
            totalProgressBar.classList.remove(...allBarClasses, ...allShadowClasses);
            totalProgressBar.classList.add('bg-yellow-300', 'shadow-[0_0_10px_rgba(253,224,71,0.5)]');
            totalProgressBar.style.width = '100%';
            
            nextUpContainer.classList.replace('opacity-100', 'opacity-0');
            btnStart.innerText = "Start";
            btnStart.classList.remove('hidden'); 
            btnPause.classList.add('hidden'); 
            beep('complete');
            speak("Workout complete! Great job!"); 
        }

        // ============================================
        // SOFT RESET FUNCTION (No Page Reload)
        // ============================================
        async function resetTimer() {
            console.log('ðŸ”„ Soft reset initiated');
            
            // Stop and clear timer
            if (timer) {
                cancelAnimationFrame(timer);
                timer = null;
            }
            
            // Cleanup resources
            await wakeLockManager.disable();
            speechManager.cancel();
            
            // Reset all state variables
            isPaused = false;
            currentPhase = 'prepare';
            globalIntervalIndex = 0;
            secondsRemaining = 0;
            totalPhaseSeconds = 0;
            initialTotalTime = 0;
            workoutEndTime = 0;
            pauseStartTime = 0;
            exerciseObjects = [];
            
            // Reset UI - Status and Exercise
            exerciseTextEl.innerText = 'Get Ready';
            exerciseTextEl.classList.remove(...allTextClasses, 'text-yellow-300', 'text-yellow-400', 'pulse-text');
            exerciseTextEl.classList.add('text-blue-400');
            
            timeLeftEl.innerText = '00:00';
            updateCountsDisplay();
            
            // Reset total time display
            updateTotalTimeDisplay(); // Instant update for reset
            
            // Reset buttons
            btnStart.innerText = "Start";
            btnStart.classList.remove('hidden');
            btnPause.classList.add('hidden');
            
            // Reset progress circle
            progressCircle.classList.remove(...allCircleClasses, 'text-yellow-400', 'text-yellow-300', 'pulse-circle-stroke');
            progressCircle.classList.add('text-blue-500');
            updateProgress(100);

            // Reset total progress bar
            totalProgressBar.classList.remove(...allBarClasses, ...allShadowClasses, 'bg-yellow-300', 'shadow-[0_0_10px_rgba(253,224,71,0.5)]');
            totalProgressBar.classList.add('bg-blue-500', 'shadow-[0_0_10px_rgba(59,130,246,0.5)]');
            
            // Remove celebration glow
            const completionGlow = document.getElementById('completion-glow');
            if (completionGlow) completionGlow.remove();
            
            // Switch to timer tab
            switchTab('timer');
            
            console.log('âœ“ Reset complete');
        }

        btnStart.addEventListener('click', async () => {
            // Initialize speech FIRST (must be synchronous in user gesture for iOS)
            speechManager.initialize();
            await soundManager.unlock();

            if (timer && isPaused) {
                togglePause();
            } else {
                startWorkout();
            }
        });
        btnPause.addEventListener('click', togglePause);
        document.getElementById('btn-reset').addEventListener('click', resetTimer);

        // Handle page visibility changes to pause/resume timer automatically
        document.addEventListener('visibilitychange', () => {
            // If timer is not running, or if it's explicitly paused by the user, do nothing.
            if (!timer || isPaused) {
                return;
            }

            if (document.hidden) {
                // Page is hidden: Implicitly pause the timer.
                // Cancel the animation loop and store the exact time when it was hidden.
                cancelAnimationFrame(timer);
                pausedTimeRemainingMs = Math.max(0, phaseEndTime - Date.now());
                pauseStartTime = Date.now();
                console.log('Page hidden, timer paused implicitly.');
            } else {
                // Page is visible: Implicitly resume the timer if it was running.
                // Check if pauseStartTime was set, which indicates an implicit pause.
                if (pauseStartTime > 0) {
                    const pauseDuration = Date.now() - pauseStartTime;
                    
                    // Adjust the master workout end time and current phase end time
                    workoutEndTime += pauseDuration;
                    phaseEndTime = Date.now() + pausedTimeRemainingMs;
                    
                    pauseStartTime = 0;
                    runTimerLoop();
                    console.log('Page visible, timer resumed implicitly.');
                }
            }
        });

        // Keyboard Shortcuts
        document.addEventListener('keydown', (e) => {
            // Ignore shortcuts if user is typing in an input field
            if (e.target.tagName === 'INPUT') return;

            switch(e.code) {
                case 'Space':
                    e.preventDefault(); // Prevent scrolling
                    if (timer || isPaused) {
                        togglePause();
                    } else {
                        speechManager.initialize();
                        soundManager.unlock().then(() => {
                            startWorkout();
                        });
                    }
                    break;
                case 'KeyR':
                    resetTimer();
                    break;
                case 'KeyM':
                    toggleMute();
                    break;
                case 'ArrowRight':
                    if (timer && !isPaused) nextPhase(true);
                    break;
            }
        });

        // Generic Pointer Events Handler for consistent button feedback across iOS/Android/PC
        document.addEventListener('pointerdown', (e) => {
            const btn = e.target.closest('.ios-button');
            if (!btn) return;

            btn.classList.add('is-pressed');
            try { btn.setPointerCapture(e.pointerId); } catch(e){}

            const clear = (e) => {
                btn.classList.remove('is-pressed');
                try { btn.releasePointerCapture(e.pointerId); } catch(e){}
                ['pointerup', 'pointercancel', 'pointerleave', 'lostpointercapture'].forEach(evt => {
                    btn.removeEventListener(evt, clear);
                });
            };
            
            ['pointerup', 'pointercancel', 'pointerleave', 'lostpointercapture'].forEach(evt => {
                btn.addEventListener(evt, clear);
            });
        });

        // Add listeners to differentiate between a tap and a scroll on touch devices
        window.addEventListener('touchstart', (e) => {
            // Reset scroll detection on a new touch
            isScrolling = false;
            touchStartY = e.touches[0].clientY;
        }, { passive: true });

        window.addEventListener('touchmove', (e) => {
            // If the touch has moved more than 10px vertically, it's a scroll
            if (Math.abs(e.touches[0].clientY - touchStartY) > 10) {
                if (!isScrolling) { // Only trigger once per scroll
                    isScrolling = true;
                    // A scroll should cancel any pending button press
                    cancelAllAdjustments();
                }
            }
        }, { passive: true });

        progressCircle.style.strokeDasharray = `${CIRCUMFERENCE} ${CIRCUMFERENCE}`;
        window.onload = () => {
            loadRoutines();
            loadSettings();
            renderExerciseList();
            setupAutoSave();
            updateAllIntervalRowDims();
            timeLeftEl.innerText = formatTime(0);
            updateTotalTimeDisplay();
            updateCountsDisplay();
        };

        window.addEventListener('beforeunload', async () => {
            await wakeLockManager.disable();
            speechManager.cancel();
        });

        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            const dropdown = document.getElementById('custom-routine-dropdown');
            if (dropdown && !dropdown.contains(e.target)) {
                toggleDropdown(false);
            }
        });
    </script>
</body>
</html>
